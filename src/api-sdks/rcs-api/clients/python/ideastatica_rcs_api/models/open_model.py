# coding: utf-8

"""
    RCS Rest API 1.0

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from ideastatica_rcs_api.models.anchor3_d import Anchor3D
from ideastatica_rcs_api.models.arc_segment3_d import ArcSegment3D
from ideastatica_rcs_api.models.base_plate3_d import BasePlate3D
from ideastatica_rcs_api.models.beam import Beam
from ideastatica_rcs_api.models.bolt_assembly import BoltAssembly
from ideastatica_rcs_api.models.check_member import CheckMember
from ideastatica_rcs_api.models.check_section import CheckSection
from ideastatica_rcs_api.models.combi_input import CombiInput
from ideastatica_rcs_api.models.concrete_setup import ConcreteSetup
from ideastatica_rcs_api.models.connection_data import ConnectionData
from ideastatica_rcs_api.models.connection_point import ConnectionPoint
from ideastatica_rcs_api.models.connection_setup import ConnectionSetup
from ideastatica_rcs_api.models.cross_section import CrossSection
from ideastatica_rcs_api.models.dapped_end import DappedEnd
from ideastatica_rcs_api.models.design_member import DesignMember
from ideastatica_rcs_api.models.detail_combination import DetailCombination
from ideastatica_rcs_api.models.detail_load_case import DetailLoadCase
from ideastatica_rcs_api.models.element1_d import Element1D
from ideastatica_rcs_api.models.element2_d import Element2D
from ideastatica_rcs_api.models.hinge_element1_d import HingeElement1D
from ideastatica_rcs_api.models.initial_imperfection_of_point import InitialImperfectionOfPoint
from ideastatica_rcs_api.models.isd_model import ISDModel
from ideastatica_rcs_api.models.line_segment3_d import LineSegment3D
from ideastatica_rcs_api.models.line_support_segment import LineSupportSegment
from ideastatica_rcs_api.models.load_case import LoadCase
from ideastatica_rcs_api.models.load_group import LoadGroup
from ideastatica_rcs_api.models.load_in_point import LoadInPoint
from ideastatica_rcs_api.models.load_on_line import LoadOnLine
from ideastatica_rcs_api.models.load_on_surface import LoadOnSurface
from ideastatica_rcs_api.models.mat_concrete import MatConcrete
from ideastatica_rcs_api.models.mat_prestress_steel import MatPrestressSteel
from ideastatica_rcs_api.models.mat_reinforcement import MatReinforcement
from ideastatica_rcs_api.models.mat_steel import MatSteel
from ideastatica_rcs_api.models.mat_welding import MatWelding
from ideastatica_rcs_api.models.material_bolt_grade import MaterialBoltGrade
from ideastatica_rcs_api.models.member1_d import Member1D
from ideastatica_rcs_api.models.member2_d import Member2D
from ideastatica_rcs_api.models.opening import Opening
from ideastatica_rcs_api.models.patch_device import PatchDevice
from ideastatica_rcs_api.models.pin import Pin
from ideastatica_rcs_api.models.point3_d import Point3D
from ideastatica_rcs_api.models.point_load_on_line import PointLoadOnLine
from ideastatica_rcs_api.models.point_on_line3_d import PointOnLine3D
from ideastatica_rcs_api.models.point_support_node import PointSupportNode
from ideastatica_rcs_api.models.poly_line3_d import PolyLine3D
from ideastatica_rcs_api.models.rebar_general import RebarGeneral
from ideastatica_rcs_api.models.rebar_shape import RebarShape
from ideastatica_rcs_api.models.rebar_single import RebarSingle
from ideastatica_rcs_api.models.rebar_stirrups import RebarStirrups
from ideastatica_rcs_api.models.region3_d import Region3D
from ideastatica_rcs_api.models.reinforced_cross_section import ReinforcedCrossSection
from ideastatica_rcs_api.models.reinforcement import Reinforcement
from ideastatica_rcs_api.models.result_class import ResultClass
from ideastatica_rcs_api.models.rigid_link import RigidLink
from ideastatica_rcs_api.models.settlement import Settlement
from ideastatica_rcs_api.models.solid_block3_d import SolidBlock3D
from ideastatica_rcs_api.models.span import Span
from ideastatica_rcs_api.models.strain_load_on_line import StrainLoadOnLine
from ideastatica_rcs_api.models.sub_structure import SubStructure
from ideastatica_rcs_api.models.surface_support3_d import SurfaceSupport3D
from ideastatica_rcs_api.models.taper import Taper
from ideastatica_rcs_api.models.temperature_load_on_line import TemperatureLoadOnLine
from ideastatica_rcs_api.models.tendon import Tendon
from ideastatica_rcs_api.models.wall import Wall
from typing import Optional, Set
from typing_extensions import Self

class OpenModel(BaseModel):
    """
    Open model
    """ # noqa: E501
    version: Optional[StrictStr] = Field(default=None, description="Data format version")
    origin_settings: Optional[Dict[str, Any]] = Field(default=None, description="OriginProject", alias="originSettings")
    point3_d: Optional[List[Point3D]] = Field(default=None, description="List of Point3D", alias="point3D")
    line_segment3_d: Optional[List[LineSegment3D]] = Field(default=None, description="List of LineSegment3D", alias="lineSegment3D")
    arc_segment3_d: Optional[List[ArcSegment3D]] = Field(default=None, description="List of ArcSegment3D", alias="arcSegment3D")
    poly_line3_d: Optional[List[PolyLine3D]] = Field(default=None, description="List of PolyLine3D", alias="polyLine3D")
    region3_d: Optional[List[Region3D]] = Field(default=None, description="List of Region3D", alias="region3D")
    mat_concrete: Optional[List[MatConcrete]] = Field(default=None, description="List of MatConcrete", alias="matConcrete")
    mat_reinforcement: Optional[List[MatReinforcement]] = Field(default=None, description="List of MatReinforcement", alias="matReinforcement")
    mat_steel: Optional[List[MatSteel]] = Field(default=None, description="List of MatSteel", alias="matSteel")
    mat_prestress_steel: Optional[List[MatPrestressSteel]] = Field(default=None, description="List of MatPrestressSteel", alias="matPrestressSteel")
    mat_welding: Optional[List[MatWelding]] = Field(default=None, description="List of MatWelding", alias="matWelding")
    mat_bolt_grade: Optional[List[MaterialBoltGrade]] = Field(default=None, description="List of BoltGrades", alias="matBoltGrade")
    cross_section: Optional[List[CrossSection]] = Field(default=None, description="List of CrossSection", alias="crossSection")
    bolt_assembly: Optional[List[BoltAssembly]] = Field(default=None, description="List of BoltAssemblys", alias="boltAssembly")
    pin: Optional[List[Pin]] = Field(default=None, description="List of Pins")
    reinforced_cross_section: Optional[List[ReinforcedCrossSection]] = Field(default=None, description="List of Reinforced CrossSection", alias="reinforcedCrossSection")
    hinge_element1_d: Optional[List[HingeElement1D]] = Field(default=None, description="List of hinge elements 1D", alias="hingeElement1D")
    opening: Optional[List[Opening]] = Field(default=None, description="List of openings for Detail")
    dapped_end: Optional[List[DappedEnd]] = Field(default=None, description="List of dapped ends in Detail", alias="dappedEnd")
    patch_device: Optional[List[PatchDevice]] = Field(default=None, description="List of dapped ends in Detail", alias="patchDevice")
    element1_d: Optional[List[Element1D]] = Field(default=None, description="List of Elements 1D", alias="element1D")
    beam: Optional[List[Beam]] = Field(default=None, description="List of Elements 1D")
    member1_d: Optional[List[Member1D]] = Field(default=None, description="List of Member 1D", alias="member1D")
    element2_d: Optional[List[Element2D]] = Field(default=None, description="List of Elements 2D", alias="element2D")
    wall: Optional[List[Wall]] = Field(default=None, description="List of Elements 2D")
    member2_d: Optional[List[Member2D]] = Field(default=None, description="List of Member 2D", alias="member2D")
    rigid_link: Optional[List[RigidLink]] = Field(default=None, description="List of Rigid link", alias="rigidLink")
    point_on_line3_d: Optional[List[PointOnLine3D]] = Field(default=None, description="List of Point on line 3D", alias="pointOnLine3D")
    point_support_node: Optional[List[PointSupportNode]] = Field(default=None, description="List of Point support in node", alias="pointSupportNode")
    line_support_segment: Optional[List[LineSupportSegment]] = Field(default=None, description="List of Line support on segment", alias="lineSupportSegment")
    loads_in_point: Optional[List[LoadInPoint]] = Field(default=None, description="List of point load impulses in this load case", alias="loadsInPoint")
    loads_on_line: Optional[List[LoadOnLine]] = Field(default=None, description="List of line load impulses in this load case", alias="loadsOnLine")
    strain_loads_on_line: Optional[List[StrainLoadOnLine]] = Field(default=None, description="List of generalized strain load impulses along the line in this load case.", alias="strainLoadsOnLine")
    point_loads_on_line: Optional[List[PointLoadOnLine]] = Field(default=None, description="List of point load impulses in this load case", alias="pointLoadsOnLine")
    loads_on_surface: Optional[List[LoadOnSurface]] = Field(default=None, description="List surafce load in this load case", alias="loadsOnSurface")
    settlements: Optional[List[Settlement]] = Field(default=None, description="Settlements in this load case")
    temperature_loads_on_line: Optional[List[TemperatureLoadOnLine]] = Field(default=None, description="List of temperature load in this load case", alias="temperatureLoadsOnLine")
    load_group: Optional[List[LoadGroup]] = Field(default=None, description="List of Load groups", alias="loadGroup")
    load_case: Optional[List[LoadCase]] = Field(default=None, description="List of Load cases", alias="loadCase")
    combi_input: Optional[List[CombiInput]] = Field(default=None, description="List of Combinations", alias="combiInput")
    attribute: Optional[List[Dict[str, Any]]] = Field(default=None, description="List of attributes")
    connection_point: Optional[List[ConnectionPoint]] = Field(default=None, description="List of Connection Points", alias="connectionPoint")
    connections: Optional[List[ConnectionData]] = Field(default=None, description="List of Connection data")
    reinforcement: Optional[List[Reinforcement]] = Field(default=None, description="List of reinforcement in IDEA StatiCa Detail")
    isd_model: Optional[List[ISDModel]] = Field(default=None, description="List of Details", alias="isdModel")
    initial_imperfection_of_point: Optional[List[InitialImperfectionOfPoint]] = Field(default=None, description="List of InitialmperfectionOfPoint", alias="initialImperfectionOfPoint")
    tendon: Optional[List[Tendon]] = Field(default=None, description="Tendon")
    result_class: Optional[List[ResultClass]] = Field(default=None, description="Result Class", alias="resultClass")
    design_member: Optional[List[DesignMember]] = Field(default=None, description="Design Member", alias="designMember")
    sub_structure: Optional[List[SubStructure]] = Field(default=None, description="Design Member", alias="subStructure")
    connection_setup: Optional[ConnectionSetup] = Field(default=None, alias="connectionSetup")
    project_data: Optional[Dict[str, Any]] = Field(default=None, description="Defines certain data about user project.", alias="projectData")
    check_member: Optional[List[CheckMember]] = Field(default=None, description="List of the Check members", alias="checkMember")
    concrete_check_section: Optional[List[CheckSection]] = Field(default=None, description="List of the concrete check section", alias="concreteCheckSection")
    concrete_setup: Optional[ConcreteSetup] = Field(default=None, alias="concreteSetup")
    project_data_concrete: Optional[Dict[str, Any]] = Field(default=None, description="Project data concrete", alias="projectDataConcrete")
    rebar_shape: Optional[List[RebarShape]] = Field(default=None, description="Gets or sets the rebars shapes", alias="rebarShape")
    rebar_general: Optional[List[RebarGeneral]] = Field(default=None, description="Gets or sets the rebar General collection", alias="rebarGeneral")
    rebar_single: Optional[List[RebarSingle]] = Field(default=None, description="Gets or sets the rebar single collection", alias="rebarSingle")
    rebar_stirrups: Optional[List[RebarStirrups]] = Field(default=None, description="Gets or sets the rebar group (stirrups) collection", alias="rebarStirrups")
    taper: Optional[List[Taper]] = None
    span: Optional[List[Span]] = None
    solid_blocks3_d: Optional[List[SolidBlock3D]] = Field(default=None, description="List of Solid Blocks 3D", alias="solidBlocks3D")
    surface_supports3_d: Optional[List[SurfaceSupport3D]] = Field(default=None, description="List of Surface Supports 3D", alias="surfaceSupports3D")
    base_plates3_d: Optional[List[BasePlate3D]] = Field(default=None, description="List of Base Plates 3D", alias="basePlates3D")
    anchors3_d: Optional[List[Anchor3D]] = Field(default=None, description="List of Anchors 3D", alias="anchors3D")
    detail_load_case: Optional[List[DetailLoadCase]] = Field(default=None, description="List of Load cases", alias="detailLoadCase")
    detail_combination: Optional[List[DetailCombination]] = Field(default=None, description="List of Combinations", alias="detailCombination")
    __properties: ClassVar[List[str]] = ["version", "originSettings", "point3D", "lineSegment3D", "arcSegment3D", "polyLine3D", "region3D", "matConcrete", "matReinforcement", "matSteel", "matPrestressSteel", "matWelding", "matBoltGrade", "crossSection", "boltAssembly", "pin", "reinforcedCrossSection", "hingeElement1D", "opening", "dappedEnd", "patchDevice", "element1D", "beam", "member1D", "element2D", "wall", "member2D", "rigidLink", "pointOnLine3D", "pointSupportNode", "lineSupportSegment", "loadsInPoint", "loadsOnLine", "strainLoadsOnLine", "pointLoadsOnLine", "loadsOnSurface", "settlements", "temperatureLoadsOnLine", "loadGroup", "loadCase", "combiInput", "attribute", "connectionPoint", "connections", "reinforcement", "isdModel", "initialImperfectionOfPoint", "tendon", "resultClass", "designMember", "subStructure", "connectionSetup", "projectData", "checkMember", "concreteCheckSection", "concreteSetup", "projectDataConcrete", "rebarShape", "rebarGeneral", "rebarSingle", "rebarStirrups", "taper", "span", "solidBlocks3D", "surfaceSupports3D", "basePlates3D", "anchors3D", "detailLoadCase", "detailCombination"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OpenModel from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in point3_d (list)
        _items = []
        if self.point3_d:
            for _item_point3_d in self.point3_d:
                if _item_point3_d:
                    _items.append(_item_point3_d.to_dict())
            _dict['point3D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in line_segment3_d (list)
        _items = []
        if self.line_segment3_d:
            for _item_line_segment3_d in self.line_segment3_d:
                if _item_line_segment3_d:
                    _items.append(_item_line_segment3_d.to_dict())
            _dict['lineSegment3D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in arc_segment3_d (list)
        _items = []
        if self.arc_segment3_d:
            for _item_arc_segment3_d in self.arc_segment3_d:
                if _item_arc_segment3_d:
                    _items.append(_item_arc_segment3_d.to_dict())
            _dict['arcSegment3D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in poly_line3_d (list)
        _items = []
        if self.poly_line3_d:
            for _item_poly_line3_d in self.poly_line3_d:
                if _item_poly_line3_d:
                    _items.append(_item_poly_line3_d.to_dict())
            _dict['polyLine3D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in region3_d (list)
        _items = []
        if self.region3_d:
            for _item_region3_d in self.region3_d:
                if _item_region3_d:
                    _items.append(_item_region3_d.to_dict())
            _dict['region3D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in mat_concrete (list)
        _items = []
        if self.mat_concrete:
            for _item_mat_concrete in self.mat_concrete:
                if _item_mat_concrete:
                    _items.append(_item_mat_concrete.to_dict())
            _dict['matConcrete'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in mat_reinforcement (list)
        _items = []
        if self.mat_reinforcement:
            for _item_mat_reinforcement in self.mat_reinforcement:
                if _item_mat_reinforcement:
                    _items.append(_item_mat_reinforcement.to_dict())
            _dict['matReinforcement'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in mat_steel (list)
        _items = []
        if self.mat_steel:
            for _item_mat_steel in self.mat_steel:
                if _item_mat_steel:
                    _items.append(_item_mat_steel.to_dict())
            _dict['matSteel'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in mat_prestress_steel (list)
        _items = []
        if self.mat_prestress_steel:
            for _item_mat_prestress_steel in self.mat_prestress_steel:
                if _item_mat_prestress_steel:
                    _items.append(_item_mat_prestress_steel.to_dict())
            _dict['matPrestressSteel'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in mat_welding (list)
        _items = []
        if self.mat_welding:
            for _item_mat_welding in self.mat_welding:
                if _item_mat_welding:
                    _items.append(_item_mat_welding.to_dict())
            _dict['matWelding'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in mat_bolt_grade (list)
        _items = []
        if self.mat_bolt_grade:
            for _item_mat_bolt_grade in self.mat_bolt_grade:
                if _item_mat_bolt_grade:
                    _items.append(_item_mat_bolt_grade.to_dict())
            _dict['matBoltGrade'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in cross_section (list)
        _items = []
        if self.cross_section:
            for _item_cross_section in self.cross_section:
                if _item_cross_section:
                    _items.append(_item_cross_section.to_dict())
            _dict['crossSection'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in bolt_assembly (list)
        _items = []
        if self.bolt_assembly:
            for _item_bolt_assembly in self.bolt_assembly:
                if _item_bolt_assembly:
                    _items.append(_item_bolt_assembly.to_dict())
            _dict['boltAssembly'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in pin (list)
        _items = []
        if self.pin:
            for _item_pin in self.pin:
                if _item_pin:
                    _items.append(_item_pin.to_dict())
            _dict['pin'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in reinforced_cross_section (list)
        _items = []
        if self.reinforced_cross_section:
            for _item_reinforced_cross_section in self.reinforced_cross_section:
                if _item_reinforced_cross_section:
                    _items.append(_item_reinforced_cross_section.to_dict())
            _dict['reinforcedCrossSection'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in hinge_element1_d (list)
        _items = []
        if self.hinge_element1_d:
            for _item_hinge_element1_d in self.hinge_element1_d:
                if _item_hinge_element1_d:
                    _items.append(_item_hinge_element1_d.to_dict())
            _dict['hingeElement1D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in opening (list)
        _items = []
        if self.opening:
            for _item_opening in self.opening:
                if _item_opening:
                    _items.append(_item_opening.to_dict())
            _dict['opening'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in dapped_end (list)
        _items = []
        if self.dapped_end:
            for _item_dapped_end in self.dapped_end:
                if _item_dapped_end:
                    _items.append(_item_dapped_end.to_dict())
            _dict['dappedEnd'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in patch_device (list)
        _items = []
        if self.patch_device:
            for _item_patch_device in self.patch_device:
                if _item_patch_device:
                    _items.append(_item_patch_device.to_dict())
            _dict['patchDevice'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in element1_d (list)
        _items = []
        if self.element1_d:
            for _item_element1_d in self.element1_d:
                if _item_element1_d:
                    _items.append(_item_element1_d.to_dict())
            _dict['element1D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in beam (list)
        _items = []
        if self.beam:
            for _item_beam in self.beam:
                if _item_beam:
                    _items.append(_item_beam.to_dict())
            _dict['beam'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in member1_d (list)
        _items = []
        if self.member1_d:
            for _item_member1_d in self.member1_d:
                if _item_member1_d:
                    _items.append(_item_member1_d.to_dict())
            _dict['member1D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in element2_d (list)
        _items = []
        if self.element2_d:
            for _item_element2_d in self.element2_d:
                if _item_element2_d:
                    _items.append(_item_element2_d.to_dict())
            _dict['element2D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in wall (list)
        _items = []
        if self.wall:
            for _item_wall in self.wall:
                if _item_wall:
                    _items.append(_item_wall.to_dict())
            _dict['wall'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in member2_d (list)
        _items = []
        if self.member2_d:
            for _item_member2_d in self.member2_d:
                if _item_member2_d:
                    _items.append(_item_member2_d.to_dict())
            _dict['member2D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in rigid_link (list)
        _items = []
        if self.rigid_link:
            for _item_rigid_link in self.rigid_link:
                if _item_rigid_link:
                    _items.append(_item_rigid_link.to_dict())
            _dict['rigidLink'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in point_on_line3_d (list)
        _items = []
        if self.point_on_line3_d:
            for _item_point_on_line3_d in self.point_on_line3_d:
                if _item_point_on_line3_d:
                    _items.append(_item_point_on_line3_d.to_dict())
            _dict['pointOnLine3D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in point_support_node (list)
        _items = []
        if self.point_support_node:
            for _item_point_support_node in self.point_support_node:
                if _item_point_support_node:
                    _items.append(_item_point_support_node.to_dict())
            _dict['pointSupportNode'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in line_support_segment (list)
        _items = []
        if self.line_support_segment:
            for _item_line_support_segment in self.line_support_segment:
                if _item_line_support_segment:
                    _items.append(_item_line_support_segment.to_dict())
            _dict['lineSupportSegment'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in loads_in_point (list)
        _items = []
        if self.loads_in_point:
            for _item_loads_in_point in self.loads_in_point:
                if _item_loads_in_point:
                    _items.append(_item_loads_in_point.to_dict())
            _dict['loadsInPoint'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in loads_on_line (list)
        _items = []
        if self.loads_on_line:
            for _item_loads_on_line in self.loads_on_line:
                if _item_loads_on_line:
                    _items.append(_item_loads_on_line.to_dict())
            _dict['loadsOnLine'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in strain_loads_on_line (list)
        _items = []
        if self.strain_loads_on_line:
            for _item_strain_loads_on_line in self.strain_loads_on_line:
                if _item_strain_loads_on_line:
                    _items.append(_item_strain_loads_on_line.to_dict())
            _dict['strainLoadsOnLine'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in point_loads_on_line (list)
        _items = []
        if self.point_loads_on_line:
            for _item_point_loads_on_line in self.point_loads_on_line:
                if _item_point_loads_on_line:
                    _items.append(_item_point_loads_on_line.to_dict())
            _dict['pointLoadsOnLine'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in loads_on_surface (list)
        _items = []
        if self.loads_on_surface:
            for _item_loads_on_surface in self.loads_on_surface:
                if _item_loads_on_surface:
                    _items.append(_item_loads_on_surface.to_dict())
            _dict['loadsOnSurface'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in settlements (list)
        _items = []
        if self.settlements:
            for _item_settlements in self.settlements:
                if _item_settlements:
                    _items.append(_item_settlements.to_dict())
            _dict['settlements'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in temperature_loads_on_line (list)
        _items = []
        if self.temperature_loads_on_line:
            for _item_temperature_loads_on_line in self.temperature_loads_on_line:
                if _item_temperature_loads_on_line:
                    _items.append(_item_temperature_loads_on_line.to_dict())
            _dict['temperatureLoadsOnLine'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in load_group (list)
        _items = []
        if self.load_group:
            for _item_load_group in self.load_group:
                if _item_load_group:
                    _items.append(_item_load_group.to_dict())
            _dict['loadGroup'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in load_case (list)
        _items = []
        if self.load_case:
            for _item_load_case in self.load_case:
                if _item_load_case:
                    _items.append(_item_load_case.to_dict())
            _dict['loadCase'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in combi_input (list)
        _items = []
        if self.combi_input:
            for _item_combi_input in self.combi_input:
                if _item_combi_input:
                    _items.append(_item_combi_input.to_dict())
            _dict['combiInput'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in connection_point (list)
        _items = []
        if self.connection_point:
            for _item_connection_point in self.connection_point:
                if _item_connection_point:
                    _items.append(_item_connection_point.to_dict())
            _dict['connectionPoint'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in connections (list)
        _items = []
        if self.connections:
            for _item_connections in self.connections:
                if _item_connections:
                    _items.append(_item_connections.to_dict())
            _dict['connections'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in reinforcement (list)
        _items = []
        if self.reinforcement:
            for _item_reinforcement in self.reinforcement:
                if _item_reinforcement:
                    _items.append(_item_reinforcement.to_dict())
            _dict['reinforcement'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in isd_model (list)
        _items = []
        if self.isd_model:
            for _item_isd_model in self.isd_model:
                if _item_isd_model:
                    _items.append(_item_isd_model.to_dict())
            _dict['isdModel'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in initial_imperfection_of_point (list)
        _items = []
        if self.initial_imperfection_of_point:
            for _item_initial_imperfection_of_point in self.initial_imperfection_of_point:
                if _item_initial_imperfection_of_point:
                    _items.append(_item_initial_imperfection_of_point.to_dict())
            _dict['initialImperfectionOfPoint'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in tendon (list)
        _items = []
        if self.tendon:
            for _item_tendon in self.tendon:
                if _item_tendon:
                    _items.append(_item_tendon.to_dict())
            _dict['tendon'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in result_class (list)
        _items = []
        if self.result_class:
            for _item_result_class in self.result_class:
                if _item_result_class:
                    _items.append(_item_result_class.to_dict())
            _dict['resultClass'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in design_member (list)
        _items = []
        if self.design_member:
            for _item_design_member in self.design_member:
                if _item_design_member:
                    _items.append(_item_design_member.to_dict())
            _dict['designMember'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in sub_structure (list)
        _items = []
        if self.sub_structure:
            for _item_sub_structure in self.sub_structure:
                if _item_sub_structure:
                    _items.append(_item_sub_structure.to_dict())
            _dict['subStructure'] = _items
        # override the default output from pydantic by calling `to_dict()` of connection_setup
        if self.connection_setup:
            _dict['connectionSetup'] = self.connection_setup.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in check_member (list)
        _items = []
        if self.check_member:
            for _item_check_member in self.check_member:
                if _item_check_member:
                    _items.append(_item_check_member.to_dict())
            _dict['checkMember'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in concrete_check_section (list)
        _items = []
        if self.concrete_check_section:
            for _item_concrete_check_section in self.concrete_check_section:
                if _item_concrete_check_section:
                    _items.append(_item_concrete_check_section.to_dict())
            _dict['concreteCheckSection'] = _items
        # override the default output from pydantic by calling `to_dict()` of concrete_setup
        if self.concrete_setup:
            _dict['concreteSetup'] = self.concrete_setup.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in rebar_shape (list)
        _items = []
        if self.rebar_shape:
            for _item_rebar_shape in self.rebar_shape:
                if _item_rebar_shape:
                    _items.append(_item_rebar_shape.to_dict())
            _dict['rebarShape'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in rebar_general (list)
        _items = []
        if self.rebar_general:
            for _item_rebar_general in self.rebar_general:
                if _item_rebar_general:
                    _items.append(_item_rebar_general.to_dict())
            _dict['rebarGeneral'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in rebar_single (list)
        _items = []
        if self.rebar_single:
            for _item_rebar_single in self.rebar_single:
                if _item_rebar_single:
                    _items.append(_item_rebar_single.to_dict())
            _dict['rebarSingle'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in rebar_stirrups (list)
        _items = []
        if self.rebar_stirrups:
            for _item_rebar_stirrups in self.rebar_stirrups:
                if _item_rebar_stirrups:
                    _items.append(_item_rebar_stirrups.to_dict())
            _dict['rebarStirrups'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in taper (list)
        _items = []
        if self.taper:
            for _item_taper in self.taper:
                if _item_taper:
                    _items.append(_item_taper.to_dict())
            _dict['taper'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in span (list)
        _items = []
        if self.span:
            for _item_span in self.span:
                if _item_span:
                    _items.append(_item_span.to_dict())
            _dict['span'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in solid_blocks3_d (list)
        _items = []
        if self.solid_blocks3_d:
            for _item_solid_blocks3_d in self.solid_blocks3_d:
                if _item_solid_blocks3_d:
                    _items.append(_item_solid_blocks3_d.to_dict())
            _dict['solidBlocks3D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in surface_supports3_d (list)
        _items = []
        if self.surface_supports3_d:
            for _item_surface_supports3_d in self.surface_supports3_d:
                if _item_surface_supports3_d:
                    _items.append(_item_surface_supports3_d.to_dict())
            _dict['surfaceSupports3D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in base_plates3_d (list)
        _items = []
        if self.base_plates3_d:
            for _item_base_plates3_d in self.base_plates3_d:
                if _item_base_plates3_d:
                    _items.append(_item_base_plates3_d.to_dict())
            _dict['basePlates3D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in anchors3_d (list)
        _items = []
        if self.anchors3_d:
            for _item_anchors3_d in self.anchors3_d:
                if _item_anchors3_d:
                    _items.append(_item_anchors3_d.to_dict())
            _dict['anchors3D'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in detail_load_case (list)
        _items = []
        if self.detail_load_case:
            for _item_detail_load_case in self.detail_load_case:
                if _item_detail_load_case:
                    _items.append(_item_detail_load_case.to_dict())
            _dict['detailLoadCase'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in detail_combination (list)
        _items = []
        if self.detail_combination:
            for _item_detail_combination in self.detail_combination:
                if _item_detail_combination:
                    _items.append(_item_detail_combination.to_dict())
            _dict['detailCombination'] = _items
        # set to None if version (nullable) is None
        # and model_fields_set contains the field
        if self.version is None and "version" in self.model_fields_set:
            _dict['version'] = None

        # set to None if point3_d (nullable) is None
        # and model_fields_set contains the field
        if self.point3_d is None and "point3_d" in self.model_fields_set:
            _dict['point3D'] = None

        # set to None if line_segment3_d (nullable) is None
        # and model_fields_set contains the field
        if self.line_segment3_d is None and "line_segment3_d" in self.model_fields_set:
            _dict['lineSegment3D'] = None

        # set to None if arc_segment3_d (nullable) is None
        # and model_fields_set contains the field
        if self.arc_segment3_d is None and "arc_segment3_d" in self.model_fields_set:
            _dict['arcSegment3D'] = None

        # set to None if poly_line3_d (nullable) is None
        # and model_fields_set contains the field
        if self.poly_line3_d is None and "poly_line3_d" in self.model_fields_set:
            _dict['polyLine3D'] = None

        # set to None if region3_d (nullable) is None
        # and model_fields_set contains the field
        if self.region3_d is None and "region3_d" in self.model_fields_set:
            _dict['region3D'] = None

        # set to None if mat_concrete (nullable) is None
        # and model_fields_set contains the field
        if self.mat_concrete is None and "mat_concrete" in self.model_fields_set:
            _dict['matConcrete'] = None

        # set to None if mat_reinforcement (nullable) is None
        # and model_fields_set contains the field
        if self.mat_reinforcement is None and "mat_reinforcement" in self.model_fields_set:
            _dict['matReinforcement'] = None

        # set to None if mat_steel (nullable) is None
        # and model_fields_set contains the field
        if self.mat_steel is None and "mat_steel" in self.model_fields_set:
            _dict['matSteel'] = None

        # set to None if mat_prestress_steel (nullable) is None
        # and model_fields_set contains the field
        if self.mat_prestress_steel is None and "mat_prestress_steel" in self.model_fields_set:
            _dict['matPrestressSteel'] = None

        # set to None if mat_welding (nullable) is None
        # and model_fields_set contains the field
        if self.mat_welding is None and "mat_welding" in self.model_fields_set:
            _dict['matWelding'] = None

        # set to None if mat_bolt_grade (nullable) is None
        # and model_fields_set contains the field
        if self.mat_bolt_grade is None and "mat_bolt_grade" in self.model_fields_set:
            _dict['matBoltGrade'] = None

        # set to None if cross_section (nullable) is None
        # and model_fields_set contains the field
        if self.cross_section is None and "cross_section" in self.model_fields_set:
            _dict['crossSection'] = None

        # set to None if bolt_assembly (nullable) is None
        # and model_fields_set contains the field
        if self.bolt_assembly is None and "bolt_assembly" in self.model_fields_set:
            _dict['boltAssembly'] = None

        # set to None if pin (nullable) is None
        # and model_fields_set contains the field
        if self.pin is None and "pin" in self.model_fields_set:
            _dict['pin'] = None

        # set to None if reinforced_cross_section (nullable) is None
        # and model_fields_set contains the field
        if self.reinforced_cross_section is None and "reinforced_cross_section" in self.model_fields_set:
            _dict['reinforcedCrossSection'] = None

        # set to None if hinge_element1_d (nullable) is None
        # and model_fields_set contains the field
        if self.hinge_element1_d is None and "hinge_element1_d" in self.model_fields_set:
            _dict['hingeElement1D'] = None

        # set to None if opening (nullable) is None
        # and model_fields_set contains the field
        if self.opening is None and "opening" in self.model_fields_set:
            _dict['opening'] = None

        # set to None if dapped_end (nullable) is None
        # and model_fields_set contains the field
        if self.dapped_end is None and "dapped_end" in self.model_fields_set:
            _dict['dappedEnd'] = None

        # set to None if patch_device (nullable) is None
        # and model_fields_set contains the field
        if self.patch_device is None and "patch_device" in self.model_fields_set:
            _dict['patchDevice'] = None

        # set to None if element1_d (nullable) is None
        # and model_fields_set contains the field
        if self.element1_d is None and "element1_d" in self.model_fields_set:
            _dict['element1D'] = None

        # set to None if beam (nullable) is None
        # and model_fields_set contains the field
        if self.beam is None and "beam" in self.model_fields_set:
            _dict['beam'] = None

        # set to None if member1_d (nullable) is None
        # and model_fields_set contains the field
        if self.member1_d is None and "member1_d" in self.model_fields_set:
            _dict['member1D'] = None

        # set to None if element2_d (nullable) is None
        # and model_fields_set contains the field
        if self.element2_d is None and "element2_d" in self.model_fields_set:
            _dict['element2D'] = None

        # set to None if wall (nullable) is None
        # and model_fields_set contains the field
        if self.wall is None and "wall" in self.model_fields_set:
            _dict['wall'] = None

        # set to None if member2_d (nullable) is None
        # and model_fields_set contains the field
        if self.member2_d is None and "member2_d" in self.model_fields_set:
            _dict['member2D'] = None

        # set to None if rigid_link (nullable) is None
        # and model_fields_set contains the field
        if self.rigid_link is None and "rigid_link" in self.model_fields_set:
            _dict['rigidLink'] = None

        # set to None if point_on_line3_d (nullable) is None
        # and model_fields_set contains the field
        if self.point_on_line3_d is None and "point_on_line3_d" in self.model_fields_set:
            _dict['pointOnLine3D'] = None

        # set to None if point_support_node (nullable) is None
        # and model_fields_set contains the field
        if self.point_support_node is None and "point_support_node" in self.model_fields_set:
            _dict['pointSupportNode'] = None

        # set to None if line_support_segment (nullable) is None
        # and model_fields_set contains the field
        if self.line_support_segment is None and "line_support_segment" in self.model_fields_set:
            _dict['lineSupportSegment'] = None

        # set to None if loads_in_point (nullable) is None
        # and model_fields_set contains the field
        if self.loads_in_point is None and "loads_in_point" in self.model_fields_set:
            _dict['loadsInPoint'] = None

        # set to None if loads_on_line (nullable) is None
        # and model_fields_set contains the field
        if self.loads_on_line is None and "loads_on_line" in self.model_fields_set:
            _dict['loadsOnLine'] = None

        # set to None if strain_loads_on_line (nullable) is None
        # and model_fields_set contains the field
        if self.strain_loads_on_line is None and "strain_loads_on_line" in self.model_fields_set:
            _dict['strainLoadsOnLine'] = None

        # set to None if point_loads_on_line (nullable) is None
        # and model_fields_set contains the field
        if self.point_loads_on_line is None and "point_loads_on_line" in self.model_fields_set:
            _dict['pointLoadsOnLine'] = None

        # set to None if loads_on_surface (nullable) is None
        # and model_fields_set contains the field
        if self.loads_on_surface is None and "loads_on_surface" in self.model_fields_set:
            _dict['loadsOnSurface'] = None

        # set to None if settlements (nullable) is None
        # and model_fields_set contains the field
        if self.settlements is None and "settlements" in self.model_fields_set:
            _dict['settlements'] = None

        # set to None if temperature_loads_on_line (nullable) is None
        # and model_fields_set contains the field
        if self.temperature_loads_on_line is None and "temperature_loads_on_line" in self.model_fields_set:
            _dict['temperatureLoadsOnLine'] = None

        # set to None if load_group (nullable) is None
        # and model_fields_set contains the field
        if self.load_group is None and "load_group" in self.model_fields_set:
            _dict['loadGroup'] = None

        # set to None if load_case (nullable) is None
        # and model_fields_set contains the field
        if self.load_case is None and "load_case" in self.model_fields_set:
            _dict['loadCase'] = None

        # set to None if combi_input (nullable) is None
        # and model_fields_set contains the field
        if self.combi_input is None and "combi_input" in self.model_fields_set:
            _dict['combiInput'] = None

        # set to None if attribute (nullable) is None
        # and model_fields_set contains the field
        if self.attribute is None and "attribute" in self.model_fields_set:
            _dict['attribute'] = None

        # set to None if connection_point (nullable) is None
        # and model_fields_set contains the field
        if self.connection_point is None and "connection_point" in self.model_fields_set:
            _dict['connectionPoint'] = None

        # set to None if connections (nullable) is None
        # and model_fields_set contains the field
        if self.connections is None and "connections" in self.model_fields_set:
            _dict['connections'] = None

        # set to None if reinforcement (nullable) is None
        # and model_fields_set contains the field
        if self.reinforcement is None and "reinforcement" in self.model_fields_set:
            _dict['reinforcement'] = None

        # set to None if isd_model (nullable) is None
        # and model_fields_set contains the field
        if self.isd_model is None and "isd_model" in self.model_fields_set:
            _dict['isdModel'] = None

        # set to None if initial_imperfection_of_point (nullable) is None
        # and model_fields_set contains the field
        if self.initial_imperfection_of_point is None and "initial_imperfection_of_point" in self.model_fields_set:
            _dict['initialImperfectionOfPoint'] = None

        # set to None if tendon (nullable) is None
        # and model_fields_set contains the field
        if self.tendon is None and "tendon" in self.model_fields_set:
            _dict['tendon'] = None

        # set to None if result_class (nullable) is None
        # and model_fields_set contains the field
        if self.result_class is None and "result_class" in self.model_fields_set:
            _dict['resultClass'] = None

        # set to None if design_member (nullable) is None
        # and model_fields_set contains the field
        if self.design_member is None and "design_member" in self.model_fields_set:
            _dict['designMember'] = None

        # set to None if sub_structure (nullable) is None
        # and model_fields_set contains the field
        if self.sub_structure is None and "sub_structure" in self.model_fields_set:
            _dict['subStructure'] = None

        # set to None if check_member (nullable) is None
        # and model_fields_set contains the field
        if self.check_member is None and "check_member" in self.model_fields_set:
            _dict['checkMember'] = None

        # set to None if concrete_check_section (nullable) is None
        # and model_fields_set contains the field
        if self.concrete_check_section is None and "concrete_check_section" in self.model_fields_set:
            _dict['concreteCheckSection'] = None

        # set to None if rebar_shape (nullable) is None
        # and model_fields_set contains the field
        if self.rebar_shape is None and "rebar_shape" in self.model_fields_set:
            _dict['rebarShape'] = None

        # set to None if rebar_general (nullable) is None
        # and model_fields_set contains the field
        if self.rebar_general is None and "rebar_general" in self.model_fields_set:
            _dict['rebarGeneral'] = None

        # set to None if rebar_single (nullable) is None
        # and model_fields_set contains the field
        if self.rebar_single is None and "rebar_single" in self.model_fields_set:
            _dict['rebarSingle'] = None

        # set to None if rebar_stirrups (nullable) is None
        # and model_fields_set contains the field
        if self.rebar_stirrups is None and "rebar_stirrups" in self.model_fields_set:
            _dict['rebarStirrups'] = None

        # set to None if taper (nullable) is None
        # and model_fields_set contains the field
        if self.taper is None and "taper" in self.model_fields_set:
            _dict['taper'] = None

        # set to None if span (nullable) is None
        # and model_fields_set contains the field
        if self.span is None and "span" in self.model_fields_set:
            _dict['span'] = None

        # set to None if solid_blocks3_d (nullable) is None
        # and model_fields_set contains the field
        if self.solid_blocks3_d is None and "solid_blocks3_d" in self.model_fields_set:
            _dict['solidBlocks3D'] = None

        # set to None if surface_supports3_d (nullable) is None
        # and model_fields_set contains the field
        if self.surface_supports3_d is None and "surface_supports3_d" in self.model_fields_set:
            _dict['surfaceSupports3D'] = None

        # set to None if base_plates3_d (nullable) is None
        # and model_fields_set contains the field
        if self.base_plates3_d is None and "base_plates3_d" in self.model_fields_set:
            _dict['basePlates3D'] = None

        # set to None if anchors3_d (nullable) is None
        # and model_fields_set contains the field
        if self.anchors3_d is None and "anchors3_d" in self.model_fields_set:
            _dict['anchors3D'] = None

        # set to None if detail_load_case (nullable) is None
        # and model_fields_set contains the field
        if self.detail_load_case is None and "detail_load_case" in self.model_fields_set:
            _dict['detailLoadCase'] = None

        # set to None if detail_combination (nullable) is None
        # and model_fields_set contains the field
        if self.detail_combination is None and "detail_combination" in self.model_fields_set:
            _dict['detailCombination'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OpenModel from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "version": obj.get("version"),
            "originSettings": obj.get("originSettings"),
            "point3D": [Point3D.from_dict(_item) for _item in obj["point3D"]] if obj.get("point3D") is not None else None,
            "lineSegment3D": [LineSegment3D.from_dict(_item) for _item in obj["lineSegment3D"]] if obj.get("lineSegment3D") is not None else None,
            "arcSegment3D": [ArcSegment3D.from_dict(_item) for _item in obj["arcSegment3D"]] if obj.get("arcSegment3D") is not None else None,
            "polyLine3D": [PolyLine3D.from_dict(_item) for _item in obj["polyLine3D"]] if obj.get("polyLine3D") is not None else None,
            "region3D": [Region3D.from_dict(_item) for _item in obj["region3D"]] if obj.get("region3D") is not None else None,
            "matConcrete": [MatConcrete.from_dict(_item) for _item in obj["matConcrete"]] if obj.get("matConcrete") is not None else None,
            "matReinforcement": [MatReinforcement.from_dict(_item) for _item in obj["matReinforcement"]] if obj.get("matReinforcement") is not None else None,
            "matSteel": [MatSteel.from_dict(_item) for _item in obj["matSteel"]] if obj.get("matSteel") is not None else None,
            "matPrestressSteel": [MatPrestressSteel.from_dict(_item) for _item in obj["matPrestressSteel"]] if obj.get("matPrestressSteel") is not None else None,
            "matWelding": [MatWelding.from_dict(_item) for _item in obj["matWelding"]] if obj.get("matWelding") is not None else None,
            "matBoltGrade": [MaterialBoltGrade.from_dict(_item) for _item in obj["matBoltGrade"]] if obj.get("matBoltGrade") is not None else None,
            "crossSection": [CrossSection.from_dict(_item) for _item in obj["crossSection"]] if obj.get("crossSection") is not None else None,
            "boltAssembly": [BoltAssembly.from_dict(_item) for _item in obj["boltAssembly"]] if obj.get("boltAssembly") is not None else None,
            "pin": [Pin.from_dict(_item) for _item in obj["pin"]] if obj.get("pin") is not None else None,
            "reinforcedCrossSection": [ReinforcedCrossSection.from_dict(_item) for _item in obj["reinforcedCrossSection"]] if obj.get("reinforcedCrossSection") is not None else None,
            "hingeElement1D": [HingeElement1D.from_dict(_item) for _item in obj["hingeElement1D"]] if obj.get("hingeElement1D") is not None else None,
            "opening": [Opening.from_dict(_item) for _item in obj["opening"]] if obj.get("opening") is not None else None,
            "dappedEnd": [DappedEnd.from_dict(_item) for _item in obj["dappedEnd"]] if obj.get("dappedEnd") is not None else None,
            "patchDevice": [PatchDevice.from_dict(_item) for _item in obj["patchDevice"]] if obj.get("patchDevice") is not None else None,
            "element1D": [Element1D.from_dict(_item) for _item in obj["element1D"]] if obj.get("element1D") is not None else None,
            "beam": [Beam.from_dict(_item) for _item in obj["beam"]] if obj.get("beam") is not None else None,
            "member1D": [Member1D.from_dict(_item) for _item in obj["member1D"]] if obj.get("member1D") is not None else None,
            "element2D": [Element2D.from_dict(_item) for _item in obj["element2D"]] if obj.get("element2D") is not None else None,
            "wall": [Wall.from_dict(_item) for _item in obj["wall"]] if obj.get("wall") is not None else None,
            "member2D": [Member2D.from_dict(_item) for _item in obj["member2D"]] if obj.get("member2D") is not None else None,
            "rigidLink": [RigidLink.from_dict(_item) for _item in obj["rigidLink"]] if obj.get("rigidLink") is not None else None,
            "pointOnLine3D": [PointOnLine3D.from_dict(_item) for _item in obj["pointOnLine3D"]] if obj.get("pointOnLine3D") is not None else None,
            "pointSupportNode": [PointSupportNode.from_dict(_item) for _item in obj["pointSupportNode"]] if obj.get("pointSupportNode") is not None else None,
            "lineSupportSegment": [LineSupportSegment.from_dict(_item) for _item in obj["lineSupportSegment"]] if obj.get("lineSupportSegment") is not None else None,
            "loadsInPoint": [LoadInPoint.from_dict(_item) for _item in obj["loadsInPoint"]] if obj.get("loadsInPoint") is not None else None,
            "loadsOnLine": [LoadOnLine.from_dict(_item) for _item in obj["loadsOnLine"]] if obj.get("loadsOnLine") is not None else None,
            "strainLoadsOnLine": [StrainLoadOnLine.from_dict(_item) for _item in obj["strainLoadsOnLine"]] if obj.get("strainLoadsOnLine") is not None else None,
            "pointLoadsOnLine": [PointLoadOnLine.from_dict(_item) for _item in obj["pointLoadsOnLine"]] if obj.get("pointLoadsOnLine") is not None else None,
            "loadsOnSurface": [LoadOnSurface.from_dict(_item) for _item in obj["loadsOnSurface"]] if obj.get("loadsOnSurface") is not None else None,
            "settlements": [Settlement.from_dict(_item) for _item in obj["settlements"]] if obj.get("settlements") is not None else None,
            "temperatureLoadsOnLine": [TemperatureLoadOnLine.from_dict(_item) for _item in obj["temperatureLoadsOnLine"]] if obj.get("temperatureLoadsOnLine") is not None else None,
            "loadGroup": [LoadGroup.from_dict(_item) for _item in obj["loadGroup"]] if obj.get("loadGroup") is not None else None,
            "loadCase": [LoadCase.from_dict(_item) for _item in obj["loadCase"]] if obj.get("loadCase") is not None else None,
            "combiInput": [CombiInput.from_dict(_item) for _item in obj["combiInput"]] if obj.get("combiInput") is not None else None,
            "attribute": obj.get("attribute"),
            "connectionPoint": [ConnectionPoint.from_dict(_item) for _item in obj["connectionPoint"]] if obj.get("connectionPoint") is not None else None,
            "connections": [ConnectionData.from_dict(_item) for _item in obj["connections"]] if obj.get("connections") is not None else None,
            "reinforcement": [Reinforcement.from_dict(_item) for _item in obj["reinforcement"]] if obj.get("reinforcement") is not None else None,
            "isdModel": [ISDModel.from_dict(_item) for _item in obj["isdModel"]] if obj.get("isdModel") is not None else None,
            "initialImperfectionOfPoint": [InitialImperfectionOfPoint.from_dict(_item) for _item in obj["initialImperfectionOfPoint"]] if obj.get("initialImperfectionOfPoint") is not None else None,
            "tendon": [Tendon.from_dict(_item) for _item in obj["tendon"]] if obj.get("tendon") is not None else None,
            "resultClass": [ResultClass.from_dict(_item) for _item in obj["resultClass"]] if obj.get("resultClass") is not None else None,
            "designMember": [DesignMember.from_dict(_item) for _item in obj["designMember"]] if obj.get("designMember") is not None else None,
            "subStructure": [SubStructure.from_dict(_item) for _item in obj["subStructure"]] if obj.get("subStructure") is not None else None,
            "connectionSetup": ConnectionSetup.from_dict(obj["connectionSetup"]) if obj.get("connectionSetup") is not None else None,
            "projectData": obj.get("projectData"),
            "checkMember": [CheckMember.from_dict(_item) for _item in obj["checkMember"]] if obj.get("checkMember") is not None else None,
            "concreteCheckSection": [CheckSection.from_dict(_item) for _item in obj["concreteCheckSection"]] if obj.get("concreteCheckSection") is not None else None,
            "concreteSetup": ConcreteSetup.from_dict(obj["concreteSetup"]) if obj.get("concreteSetup") is not None else None,
            "projectDataConcrete": obj.get("projectDataConcrete"),
            "rebarShape": [RebarShape.from_dict(_item) for _item in obj["rebarShape"]] if obj.get("rebarShape") is not None else None,
            "rebarGeneral": [RebarGeneral.from_dict(_item) for _item in obj["rebarGeneral"]] if obj.get("rebarGeneral") is not None else None,
            "rebarSingle": [RebarSingle.from_dict(_item) for _item in obj["rebarSingle"]] if obj.get("rebarSingle") is not None else None,
            "rebarStirrups": [RebarStirrups.from_dict(_item) for _item in obj["rebarStirrups"]] if obj.get("rebarStirrups") is not None else None,
            "taper": [Taper.from_dict(_item) for _item in obj["taper"]] if obj.get("taper") is not None else None,
            "span": [Span.from_dict(_item) for _item in obj["span"]] if obj.get("span") is not None else None,
            "solidBlocks3D": [SolidBlock3D.from_dict(_item) for _item in obj["solidBlocks3D"]] if obj.get("solidBlocks3D") is not None else None,
            "surfaceSupports3D": [SurfaceSupport3D.from_dict(_item) for _item in obj["surfaceSupports3D"]] if obj.get("surfaceSupports3D") is not None else None,
            "basePlates3D": [BasePlate3D.from_dict(_item) for _item in obj["basePlates3D"]] if obj.get("basePlates3D") is not None else None,
            "anchors3D": [Anchor3D.from_dict(_item) for _item in obj["anchors3D"]] if obj.get("anchors3D") is not None else None,
            "detailLoadCase": [DetailLoadCase.from_dict(_item) for _item in obj["detailLoadCase"]] if obj.get("detailLoadCase") is not None else None,
            "detailCombination": [DetailCombination.from_dict(_item) for _item in obj["detailCombination"]] if obj.get("detailCombination") is not None else None
        })
        return _obj


