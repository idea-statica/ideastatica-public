{
  "articles/diagnostics.html": {
    "href": "articles/diagnostics.html",
    "title": "| IDEA StatiCa API",
    "keywords": "Within the checkbot framework, we provide the ability to log events within diagnostics files associated with your projects. It should provide users with information about limitations and restrictions to the plug-in. It is important to enable this feature to give users the ability to drill down into problems they may be facing when importing or running a third-party plug-in. Accessing Diagnostics Files The log file is located in the users's temp folder: _C:\\Users\\USER NAME\\AppData\\Local\\Temp\\IdeaStatiCa\\Logs\\IdeaStatiCaCodeCheckManager.log_. Our diagnostics uses a rolling file sink. If the size of a log file exceeds a limit a new log file is added e.g. IdeaStatiCaCodeCheckManager_001.log. The diagnostics log files can also be opened directly from our example application - see the button Show CCM Log. Setting of the severity of messages in the log file The severity level of messages which are written into a log file can be configured in the file IdeaDiagnostics.config which can be found in the IdeaStatiCa temp folder: C:\\Users\\USER NAME\\AppData\\Local\\IDEA_RS\\IdeaDiagnostics.config <IdeaDiagnosticsSettings> <DefaultLogLevel loglevel=\"Debug\"/> <!-- <LoggerLogLevel loggername=\"app.program\" loglevel=\"Debug\"/> --> <!-- <DebugView active=\"false\"/> --> </IdeaDiagnosticsSettings> The default value of Severity is Information. If it is changed to Debug or Trace more details are written to the log file."
  },
  "articles/nugetpackages.html": {
    "href": "articles/nugetpackages.html",
    "title": "IDEA StatiCa NuGet Packages | IDEA StatiCa API",
    "keywords": "IDEA StatiCa NuGet Packages The packages which are described in this documentation can be installed through NuGet packages. You can find the latest IDEA StatiCa Nuget Packages here: IDEA StatiCa Learn how to manage NuGet packages in Visual Studio here It is recommend where possible to update to the latest version of the NuGet package to benefit for the latest API enhancements."
  },
  "articles/releasenotes.html": {
    "href": "articles/releasenotes.html",
    "title": "| IDEA StatiCa API",
    "keywords": ""
  },
  "docs/api/api_create_a_simple_app.html": {
    "href": "docs/api/api_create_a_simple_app.html",
    "title": "Simple App Creation | IDEA StatiCa API",
    "keywords": "A simple app is defined by creating a 'one-time' IOM export or conversion from a third-party application or file format. Examples of Simple Apps: Create an IDEA connection file (.ideaCon) file from a node selection in an FEA or BIM software. Create an app to allow conversion of one file format into IOM Open Model format. Export the entire file or partial file (including results) to an IOM ModelBIM file to import into Checkbot. Benefits of simple apps: Simple apps can be highly customized based on third-party user interfaces. Can be created using Windows form or Console Applications projects. Primarily rely on simple IOM OpenModel creation. Can use IDEAs cloud service to generate .ideaCon connection files. Integrate well with single connection optimization procedures and Template Applications. Limitations to simple apps: Conversion of project materials and properties needs to be defined within the app and is not persistent. No framework for syncing and updating once a connection has been created. If the model is updated the connection will need to be regenerated. Anatomy of a Simple App The below provides a reference for the information contained below on the anatomy of options for simple app creation. Simple App Creation IDEA StatiCa Connection File from Third-party App. Probably the most widely used case for a Simple App is to export a single IDEA Connection file from a third-party application. 1. Define the Project Type, UI, and Features It is up to the developer to define what features they want to include in the export. There is a list of case studies below that give insight into available options. 2. Create/Convert to IOM Open Model The primary exercise is to convert the base application geometry schema to an IOM Model, which can be read by IDEA StatiCa Connection. The Steel Frame Example walks step-by-step through the primary class and generation of an IOM Model for a Steel Structure. Notes on the Steel Frame Example In the Steel Frame Example only one ConnectionPoint is defined within the Open Model output. IDEA StatiCa connection only allows for one connection to be imported through IOM (although the program itself does allow multiple connections). This is worth noting when trying to create multiple IDEA StatiCa connection files using this method. A separate IOM .xml file will need to be created with all relevant data. The IOM Wiki page provides some further in-depth documentation on more complex aspects of generating an IOM model. 3. Extract the IOM Open Model Results (For FEA Apps) For IOM coming from an FEA application, it is important that an IOM OpenModelResult .xml/.xmlR is created. This file provides all the result data required to provide load effects on the connection. Again, Steel Frame Example provides a brief explanation on how this is generated. Notes on the Steel Frame Example In contrary to the above, you can reference one single result file for the creation of all connection IOM exports. Result Forces for members not in the connection file will be ignored. The Steel Frame Example provides definitions of load groups, load cases, and load combinations. In practice, if the load combined effects for a load combination can be directly provided you can simply provide these results as a load case. The IOM Wiki pages below provide some further in-depth documentation on helping to generate IOM Result Files: IOM Coordinate System IOM Member Force Result Data IOM Load Groups, Cases, Combinations 4. Create the IDEA StatiCa Connection file Once the IOM OpenModel and IOM OpenResult have been generated using one of the following options to create the .IdeaCon connection file: IDEA StatiCa Connection File using PlugIn (API) string iomFileName = \"example.xml\"; //If no results then set this string to String.Empty string iomResFileName = \"example.xmlR\"; //Getting Desktop for this Example var desktopDir = Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory); var fileConnFileNameFromLocal = Path.Combine(desktopDir, \"connectionFromIOM-local.ideaCon\"); //Using IdeaStatiCa.Plugin Package var calcFactory = new ConnHiddenClientFactory(IdeaInstallDir); var client = calcFactory.Create(); try { //Creates connection project from IOM. This does not leave the connection open. client.CreateConProjFromIOM(iomFileName, iomResFileName, fileConnFileNameFromLocal); } catch(Exception e) { Console.WriteLine(\"Error '{0}'\", e.Message); } finally { if (client != null) { client.Close(); } } IDEA StatiCa Connection File using Online Service It allows to generate idea connection project without having Idea StatiCa on your PC. IOM and IOM results are sent to webservice which generates and returns Idea Connection project. public static void CreateOnServer(OpenModel model, OpenModelResult openModelResult, string path) { IdeaRS.OpenModel.OpenModelContainer openModelContainer = new OpenModelContainer() { OpenModel = model, OpenModelResult = openModelResult, }; // serialize IOM to XML var stringwriter = new System.IO.StringWriter(); var serializer = new XmlSerializer(typeof(OpenModelContainer)); serializer.Serialize(stringwriter, openModelContainer); string viewerURL = \"https://viewer.ideastatica.com\"; var serviceUrl = viewerURL + \"/ConnectionViewer/CreateFromIOM\"; Console.WriteLine(\"Posting iom in xml to the service {0}\", serviceUrl); var resultMessage = Helpers.PostXMLData(serviceUrl, stringwriter.ToString()); ResponseMessage responseMessage = JsonConvert.DeserializeObject<ResponseMessage>(resultMessage); Console.WriteLine(\"Service response is : '{0}'\", responseMessage.status); if (responseMessage.status == \"OK\") { byte[] dataBuffer = Convert.FromBase64String(responseMessage.fileContent); Console.WriteLine(\"Writing {0} bytes to file '{1}'\", dataBuffer.Length, path); if (dataBuffer.Length > 0) { using (FileStream fileStream = new FileStream(path , FileMode.Create , FileAccess.Write)) { fileStream.Write(dataBuffer, 0, dataBuffer.Length); } } else { Console.WriteLine(\"The service returned no data\"); } } } Launching IDEA StatiCa from your App. Once the .ideaCon file has been created, you can choose to launch the IDEA StatiCa App directly from your application for editing and saving the user from having to open IDEA StatiCa and locate the file. The steps to enable this interaction are explained here. Note: This primarily only works for apps creating one connection file. Allow Simple Checkbot Import through ModelBIM. If you are wanting to use Checkbot for its advanced connection and member management features you can create an XML export of the IdeaStatiCa.PlugIn.ModelBIM class. A user can then import that file to view connections and defined results. More benefits will also be seen as the Checkbot application improves. In order to do this, multiple connections should be defined in the IOM Data and then specified in the ModelBIM. Below shows how this can be done. //connections: A list of Connection Ids that .IdeaCon files should be generated when file imported. //members: A list of Member Ids that .IdeaMember files should be generated when file imported. public static ModelBIM generateIOMModelBIM(OpenModel model, OpenModelResult results, List<int> connections, List<int> members) { ModelBIM modelBIM = new ModelBIM(); modelBIM.Results = results; modelBIM.Model = model; //Connection Items List<BIMItemId> items = new List<BIMItemId>(); foreach (int ConnectionId in connections) items.Add(new BIMItemId() { Id = ConnectionId, Type = BIMItemType.Node }); //Member Items List<BIMItemId> memberItems = new List<BIMItemId>(); foreach (int memberId in members) items.Add(new BIMItemId() { Id = memberId, Type = BIMItemType.Member }); modelBIM.Items = items; modelBIM.Messages = new IdeaRS.OpenModel.Message.OpenMessages(); return modelBIM; } the ModelBIM can then be serialized to an .XML file which can be imported into Checkbot. public static void SaveModelBIM(ModelBIM modelBim, string filePath) { XmlSerializer xs = new XmlSerializer(typeof(ModelBIM)); using(Stream fs = new FileStream(xmlFileName, FileMode.Create)) { using(XmlTextWriter writer = new XmlTextWriter(fs, Encoding.Unicode)) { writer.Formatting = Formatting.Indented; // Serialize using the XmlTextWriter. xs.Serialize(writer, modelBIM); } } } Further Resources Simple App Case Studies SPACE GASS - A simple FEA Connection App for SpaceGass Structural Analysis Software KarambaIDEA - An OpenSource App which generates IDEA StatiCa Connection files from Rhino and Grasshopper."
  },
  "docs/api/api_iom_vs_api.html": {
    "href": "docs/api/api_iom_vs_api.html",
    "title": "| IDEA StatiCa API",
    "keywords": ""
  },
  "docs/api/api_overview.html": {
    "href": "docs/api/api_overview.html",
    "title": "| IDEA StatiCa API",
    "keywords": ""
  },
  "docs/api/api_parameter_reference_guide.html": {
    "href": "docs/api/api_parameter_reference_guide.html",
    "title": "Expression Parameter Reference | IDEA StatiCa API",
    "keywords": "Expression Parameter Reference The below provides further information on using expressions in IDEA StatiCa Connection. More general information on using parameters can be found here. Introduction We use a third-party expression module called NCalc to enable the evaluation of expressions both in the Parameters functionality (developer tab) and special evaluation calls available in the Connection API. The below is an extension to the ncalc documentation where all standard math, logical operators and functions are explained. On top of the out-of-the-box functions that are provided, several additional expressions functions are available within the Connection App to extend functionally specific to the IDEA StatiCa connection. These include providing functions that can reference existing geometric properties in a given connection, which can allow the driving of other specific connection detailing parameters. Simple Functions The below table provides the basic expression functions typically required to enable the use of parameters: Expression Description Example Input Example Ouput ToString(..) Converts a number to a string ToString(2.1578) '2.1578' ToString(..) Concatenates multiple strings into one output ToString('M',20,' ','8.8') 'M20 8.8' ToString(..) Each comma delineated input is also separately evaluated. spacing and bolts are previously defined parameters ToString([spacing],'*',[bolts]-1) '.075*3' Round(..) rounds a decimal number to an Integer Round(2.1578, 0) 2 Round(..) rounds a decimal number to a precision three Round(2.1578, 3) 2.158 Model Property Reference Functions Model property functions are an advanced feature, and should be limited where possible. Further enhancement of these will be made in the future. Member Property Functions The GetValue() Function can be used to extract model properties from the connection model. This enables the extraction of member information such as cross-section information, member geometry, etc. Expression Description Example Input Example Ouput GetValue(..) Gets a property associated with a member in the model, where B is the Member Name GetValue('B', 'cssWidth') 89 In all examples below 'B' represents the Name of the referenced member in the Connection Project Member Cross Section Bounds Item Expression Comment Height GetValue('B', 'CrossSection.Bounds.Height') Width GetValue('B', 'CrossSection.Bounds.Width') Bottom GetValue('B', 'CrossSection.Bounds.Bottom') Left GetValue('B', 'CrossSection.Bounds.Left') Right GetValue('B', 'CrossSection.Bounds.Right') Top GetValue('B', 'CrossSection.Bounds.Top') Direct Access Member Properties Item Expression Comment Flange Thickness GetValue('B', 'FlangeThickness') Web Thickness GetValue('B', 'WebThickness') InsertPointOnRefLine GetValue('B', 'InsertPointOnRefLine.X') DirVectX GetValue('B', 'DirVectX') DirVectY GetValue('B', 'DirVectY') DirVectZ GetValue('B', 'DirVectZ') Length GetValue('B', 'Length') Support Code GetValue('B', 'SupportCode') Material Name GetValue('B','MaterialName') Angle Alpha GetValue('B', 'AngleAlpha') Angel Beta GetValue('B','AngleBeta') Theoretical Length Y GetValue('B', 'TheoreticalLengthY') Theoretical Length Z GetValue('B', 'TheoreticalLengthZ') Further Member Properties Item Expression Comment Is Bearing Member GetValue('B','IsBearingMember') Gets the flag of bearing member Connection Point - X GetValue('B', 'ConnectionPoint.X') Gets the point of connection of this segment to the joint Connection Point - Y GetValue('B', 'ConnectionPoint.Y') Connection Point - Z GetValue('B', 'ConnectionPoint.Z') Position On Ref Line GetValue('B', 'PositionOnRefLine') Gets the relative position of the ConnectionPoint on the ReferenceLine Calculated Pin Position GetValue('B', 'CalculatedPinPosition') Gets the position of the calculated pinned connection. The position is measured on the local X-axis of the beam. The calculation is done according to the sizes and positions of bolts on this member Bounding Box in LCS - Height GetValue('B', 'BoundingBoxInLcs.Height') Gets bounding box in the local coordinate system of the beam Bounding Box in LCS - Width GetValue('B', 'BoundingBoxInLcs.Width) Bounding Box in LCS - Length GetValue('B', 'BoundingBoxInLcs.Length) Beam Relating Section Properties Item Expression Comment Area GetValue('B', 'CrossSection.CssCharact.A') Area of Cross Section Av1 GetValue('B','CrossSection.CssCharact.Av1') Shear area Av1 (major principal axis) Av2 GetValue('B','CrossSection.CssCharact.Av2') Shear area Av2 (minor principal axis) Sx GetValue('B', 'CrossSection.CssCharact.Sx') The first moment of area related to the X axis Sy GetValue('B', 'CrossSection.CssCharact.Sy') The first moment of area related to the Y axis Ix GetValue('B', 'CrossSection.CssCharact.Ix') The second moment of area related to the X axis Iy GetValue('B', 'CrossSection.CssCharact.Iy') The second moment of area related to the Y axis I1 GetValue('B', 'CrossSection.CssCharact.I1') The principal second moment of area related to the first principal axis I2 GetValue('B', 'CrossSection.CssCharact.I2') The principal second moment of area related to the second principal axis Alpha GetValue('B', 'CrossSection.CssCharact.Alpha') Gets the angle, in radians, between system and principal axes It GetValue('B', 'CrossSection.CssCharact.It') Sant Vennant torsional constant Ixy GetValue('B', 'CrossSection.CssCharact.Ixy') The product moment of area Cgx GetValue('B', 'CrossSection.CssCharact.Cgx') Gets the centre of gravity related to the X axis Cgy GetValue('B', 'CrossSection.CssCharact.Cgy') Gets the centre of gravity related to the Y axis Painting Surface GetValue('B', 'CrossSection.CssCharact.PaintingSurface') Painting surface as surface of 1m long part of beam with that cros section Wpl1 GetValue('B', 'CrossSection.CssCharact.Wpl1') Plastic modulus related to major principal axis Wpl2 GetValue('B', 'CrossSection.CssCharact.Wpl2') Plastic modulus related to minor principal axis Wel1 GetValue('B', 'CrossSection.CssCharact.Wel1') Section modulus related to major principal axis Wel2 GetValue('B', 'CrossSection.CssCharact.Wel2') Section modulus related to minor principal axis Iw GetValue('B', 'CrossSection.CssCharact.Iw') Warping Constant C GetValue('B', 'CrossSection.CssCharact.C') Torsion Constant Rgx GetValue('B', 'CrossSection.CssCharact.Rgx') Gets the radius of gyration related to the X axis Rgy GetValue('B', 'CrossSection.CssCharact.Rgy') Gets the radius of gyration related to the Y axis Rg1 GetValue('B', 'CrossSection.CssCharact.Rg1') Gets the radius of gyration related to the first principal axis Rg2 GetValue('B', 'CrossSection.CssCharact.Rg2') Gets the radius of gyration related to the second principal axis x0 GetValue('B', 'CrossSection.CssCharact.x0') Shear centre distance from centroidal point in X direction y0 GetValue('B', 'CrossSection.CssCharact.y0') Shear centre distance from centroidal point in Y direction Beam Relating Section Material Item Expression Comment E GetValue('B', 'Material.E') Young's modulus G GetValue('B', 'Material.G') Shear modulus Poisson GetValue('B', 'Material.Poissons') Poisson's ratio Unit Mass GetValue('B', 'Material.UnitMass') UnitMass Specific Heat GetValue('B', 'Material.SpecificHeat') Specific heat capacity Thermal Expansion GetValue('B', 'Material.ThermalExpansion') Thermal Expansion Thermal Conductivity GetValue('B', 'Material.ThermalConductivity') Thermal Conductivity Is Default Materail GetValue('B', 'Material.IsDefaultMaterial') True if material is default material from the code Operation Reference Functions Currently operation reference functions only exist for internal use. Please let us know what model information you require to retrieve from operations and so we can add appropriate public functions."
  },
  "docs/api/api_parameters_getting_started.html": {
    "href": "docs/api/api_parameters_getting_started.html",
    "title": "| IDEA StatiCa API",
    "keywords": "Below provides an introduction to the use of parameters in IDEA StatiCa Connection. Parameters can be accessed by [enabling the Developer Mode] in the connection application. Introduction IDEA StatiCa Connection v23 provides an improved experience for creating and setting parameters in an IDEA StatiCa Connection Project. Parameters can be used to facilitate many functions including: Parametric templates. Connection sensitivity studies. Connection part optimisation. Machine learning algorithms and studies. Parameters are specific to one item in a connection project. This allows parameters to be exported inside of connection templates which are saved from a connection project item. It is recommended, although not required, that when using parameters, only one connection item is present in the connection project. Accessing parameters Parameters can be accessed through the Developer Tab. Parameters vs API Parameters can be seen as a middle ground between API functionally and the classic UI of the program. All functionality (input/outputs) of the program should ideally be available through the API, however, Parameters allow for certain specific inputs to be linked within a connection project. Enabling parameters allows easy access through a high-level call in the API, making it a lot easier for a user to programmatically update specifically targeted inputs without needing to understand the finer details of the API. Parameters also allow the passing of these high-level links across Connection projects, which is beneficial for designing similar connection types with different loading and geometry configurations. Terminology Item Description Parameter A parameter is a global value that can be used as input to one or more model properties. Parameters are typeless and hold no specific type or unit information. Parameters are validated only once assigned to a model property. See below for more information. Model property Model properties are inputs or selections that are available in a project that can be driven by a parameter. Typically, inputs should mimic the input available in the UI of the project. Only one parameter can be linked to any model property. Model Property Type Each model property is of a specific type. The model property type provides the requirements for validation. For number-type properties, it also provides the required output unit. Output units are derived from the current unit settings in the project. Property Item A property item is a high-level item under which model properties are grouped in the model properties selection table. Property items can be either a project item (material, etc) or specific to a connection item (member, operation etc). Some property items include materials, cross-sections, members, and operations. Model Property Group Model properties are grouped to match different sections of the Program to allow staged application of model properties. These groups include libraries (materials and cross-sections), members, and operations. Parameters Parameters are type-less and unit-less. They are either a number or a string. Where a parameter needs to be applied to a model property with a number input property the parameter should be provided as an SI unit to the Model Property. A conversion will take place to convert it to the appropriate model units assigned to the current Project. Parameter input All parameters are now evaluated as expressions. We use an expression module called ncalc that provides access to basic math functions and operations. Inputs generally need to be separately identified between strings, decimal numbers, and integers. The table below shows how different basic types should be provided in the expression editor. Basic Input Type Description Example Strings strings should be provided with single quotation marks. 'myString' Decimal number1 decimal numbers should have a 0 or Integer prefix and contain a decimal point. 0.45 Integer Integers should be whole numbers without any decimators. Use Round( ) where a decimal number is referenced. 3 Reference reference a previous parameter in the list by using square brackets. [param1] Currently only decimal point input is allowed when defining parameters. Decimal commas, based on user PC settings will be supported in future. Units Currently, all parameter inputs need to be provided in basic SI Units. Please see the link here for reference. Expression methods Expression methods can be used to perform the transformation of basic type inputs to more complex inputs required by some Model properties. This primarily involves concatenating strings and providing referencing ability to previously defined parameters. The below table provides the basic expression functions typically required to enable the use of parameters: Expression Description Example Input Example Ouput ToString(..) Converts a number to a string ToString(2.1578) '2.1578' ToString(..) Concatenates multiple strings into one output ToString('M',20,' ','8.8') 'M20 8.8' ToString(..) Each comma delineated input is also separately evaluated. spacing and bolts are previously defined parameters ToString([spacing],'*',[bolts]-1) '.075*3' RoundNumber(..) rounds a decimal number to an Integer Round(2.1578, 0) 2 RoundNumber(..) rounds a decimal number to a precision three Round(2.1578, 3) 2.158 For a further and full explanation of available expression methods refer to the Parameter Reference Guide Advanced expression methods There are further advanced Expression methods that can retrieve parameters currently available to be accessed from parts of an existing model using specific evaluation strings. This is currently an advanced feature and will be developed further in the future. Refer to the Parameter Reference Guide Model properties Model property validation The below table provides basic validation criteria for different model property types. Model Property Type Basic Type Validation1 Example Simple String string Boolean string 'true' or 'false' Enum string 'Rear' or 'Both' or 'End' Integer int 3 Float float, int 3.0 or 0.12 Complex Number groups string (format varies, ref UI) '.0075*3' or '0.075; 0.05' Vector string (format 'X Y Z') '0.0 0.0 1.0' Library2 Material string 'S 355' Bolt Assembly string 'M20 8.8' Cross-section string 'IPE220' Model properties are validated by priority, an attempt for validation will be undertaken on the primary input type. If unsuccessful a parsing/casting to the second validation type will be tried. Validation of library properties can change depending on the property item that it is assigned to. Refer below. Library model properties Validation of library properties such as Material, Bolt Assembly and Cross-section changes depending on the property item that it is assigned under. A library property can be validated in two ways: Method 1. Against the items currently available in the Project database or; Method 2. Against the available possibilities in a user MPRL database For a Cross-section or Plate Operation project item, Method 1 is used and the project database is searched and that material is referenced. For a Material project item, Method 2 is used, the user's MPRL is searched by name and if found that material is changed to the found material. Therefore, parameters cannot add materials to the current Project database. These would need to be added manually or through the API. Transferring parameters between projects Parameters and Model Properties can be exported and used in another project using the developer mode template functionality and available API calls. When a template is saved manually from the developer tab, parameters and associated model properties are saved into the template itself. When the template is then applied to a clean/naked connection (one without operations), those operations are assigned and parameters and model properties should also be available for editing. Note that the developer tab ‘Templates’ functionality is like that provided through the API for saving and applying templates. Further information and examples Webinar on using parameters for optimization Parameter Expression Reference Guide"
  },
  "docs/api/dotnet/api_dotnet_getting_started.html": {
    "href": "docs/api/dotnet/api_dotnet_getting_started.html",
    "title": "| IDEA StatiCa API",
    "keywords": ""
  },
  "docs/api/python/api_install_python_and_jupyterlab_using_anaconda.html": {
    "href": "docs/api/python/api_install_python_and_jupyterlab_using_anaconda.html",
    "title": "| IDEA StatiCa API",
    "keywords": "The below provides instructions on how to install Python and JupyterLab/Notebook using Anaconda. Step 1: Install Anaconda Anaconda automatically installs Python and most of the packages used in python programming. Go to the Anaconda website and install Anaconda Follow all the recommended installation options. Step 2: Install python .NET on Anaconda Environment As the IDEA IOM and API are provided as .NET modules we will need to install python .Net within our python environment. Open Anaconda Navigator Application and then open the anaconda shell. Copy and paste the below to Add. conda install -c conda-forge pythonnet ENURE that python .Net Version 3 or greater is installed. Wait for confirmation python .Net has been installed and then close the Powershell window. Step 3: Launch JupyterLab from Anaconda Navigator and Test IdeaStatiCa.PlugIn We can now open JupyterLab directly from the Anaconda Navigator Start a new notebook and use the following code to test import clr import sys import json import math import os idea_path = \"C:\\Program Files\\IDEA StatiCa\\StatiCa 22.1\" sys.path.append(idea_path); clr.AddReference('IdeaStatiCa.Plugin') from IdeaStatiCa.Plugin import ConnHiddenClientFactory factory = ConnHiddenClientFactory(idea_path) client = factory.Create() client.OpenProject('MyConnectionProject.ideaCon') ## Do Something with the Opened Project. client.CloseProject() client.Close() If an error occurs, try to restart the kernel and re-run from top to bottom."
  },
  "docs/api/python/api_python_create_python_stubs.html": {
    "href": "docs/api/python/api_python_create_python_stubs.html",
    "title": "Create Python Stubs Files | IDEA StatiCa API",
    "keywords": "The following explains how to enable auto-completion of code in Visual Studio Code (VSC). In order to get auto-completion working for imported IDEA Modules in Visual Studio Code when using Python, you need to create a Python 'stubs' folder for IDEA StatiCa modules. Stubs folders contain the skeleton information of a module that can be read by VSC to provide auto-completion. Software Requirements: Visual Studio GitHub Desktop (Optional) Create Python Stubs Files There are a number of tools that can create stub files for a .Net assembly: A good opensource tool we have found is developed by McNeel called PyStubler. This is used by McNeel to generate the stubs for their own .Net assemblies. We will use it here, to generate stubs for IdeaStatiCa.Plugin and IdeaRS.OpenModel. Clone the repository of pythonstubs to your computer. If you are a Github beginner, we recommend downloading Github desktop. Open the pythonstubs Repository folder and open the PyStublerNet.sln solution which is located in the 'builder' folder. When open, go the the PyStubbler projects properties. Replace the command line arguments with the location of the Idea .dlls you want to create stubs for. --dest=\".\\Idea\" --search=\"C:\\\\Program Files\\\\IDEA StatiCa\\\\StatiCa 21.1\" \"C:\\\\Program Files\\\\IDEA StatiCa\\\\StatiCa 21.1\\\\IdeaStatiCa.Plugin.dll\" \"C:\\\\Program Files\\\\IDEA StatiCa\\\\StatiCa 21.1\\\\IdeaRS.OpenModel.dll\" Build and then Run the PyStubbler project. The following folders will be generated in the project bin folder. Copy and paste these folders into the folder you are setting as the system path directory for the Reference Assemblies. In the case of Python, this is likely the IDEA StatiCa Programs Files directory. Restart Visual Studio Code to ensure the auto-completion takes effect. Note: For each update of the API or program the stubs should be updated to avoid conflicts or not provide auto-complete for new updates!"
  },
  "docs/api/python/api_python_getting_started.html": {
    "href": "docs/api/python/api_python_getting_started.html",
    "title": "| IDEA StatiCa API",
    "keywords": ""
  },
  "docs/api/python/api_using_api_in_grasshopper.html": {
    "href": "docs/api/python/api_using_api_in_grasshopper.html",
    "title": "| IDEA StatiCa API",
    "keywords": "Grasshopper is a great way to utilize the IDEA StatiCa API to perform optimization and retrieve connection results. Any of the scripting components available in out-of-the-box grasshopper can be used to Automate IDEA through the API. As most of the output that is provided by the API can be serialized or represented in a JSON format it is easy to retrieve output by using available plug-ins in Grasshopper. jSwan is a great plugin for working with JSON strings. GhPython GhPython is a powerful scripting component that allows a user to run python code within Grasshopper. Most of the Python examples provided should work when used inside GhPython. The example code below provides an example of how an IDEA Connection file can be run and the bolt forces extracted using GhPython. jSwan is then used to filter specific results from the JSON output. Copy and paste the following code into a GhPython component. Note: The trigger component is used to stop the component from running consistently as calculation may take some time. Before running the script: Change the ideaCon_filename to a prepared .ideaCon file which has some bolts in it. Make sure the Connection file is located in the same folder as the Grasshopper script and the grasshopper script is saved. The GH script is used to find the file automatically. \"\"\"Provides a scripting component. Inputs: x: The x script variable y: The y script variable Output: a: The a output variable\"\"\" __author__ = \"NathanLuke\" __version__ = \"2022.04.12\" import Grasshopper as gh import rhinoscriptsyntax as rs import clr import sys import json import math import os # the path to the idea connection installation directory idea_path = r\"C:\\Program Files\\IDEA StatiCa\\StatiCa 21.1\" # modify path to be able to load .net assemblies sys.path.append(idea_path) # load the assembly IdeaStatiCa.Plugin which is responsible for communication with IdeaStatiCa clr.AddReference('IdeaStatiCa.Plugin') from IdeaStatiCa.Plugin import ConnHiddenClientFactory # find the directory of this script to fetch idea file. ghfilepath = ghenv.LocalScope.ghdoc.Path script_dir = os.path.dirname(ghfilepath) # the name of idea connection project which is used in this script ideaCon_filename = r\"BoltResultTest.ideaCon\" connection_project_path = os.path.join(script_dir, ideaCon_filename) # create the instance of the client which communicates with IdeaStatiCa factory = ConnHiddenClientFactory(idea_path) ideaConnectionClient = factory.Create() # open idea connection project ideaConnectionClient.OpenProject(connection_project_path) # get information about connections in the project and print them projectInfo = ideaConnectionClient.GetProjectInfo() connections = projectInfo.Connections for conn in connections: print(f'{conn.Name} { conn.Identifier}') # Get Connection Info of First Connection in file firstCon = connections[0] # Runs Calculation briefResults = ideaConnectionClient.Calculate(firstCon.Identifier) # Get Detailed Results Info of the check of the first connection checkResults_json_string = ideaConnectionClient.GetCheckResultsJSON(firstCon.Identifier) #Convert Result to JSON pyJSON = json.loads(checkResults_json_string) #Find Bolt Results boltJSON = pyJSON['bolts'] #Return Bolt Results to GhPython Component Output Parameter a = json.dumps(boltJSON, indent = 4) # Close idea connection project ideaConnectionClient.CloseProject() ideaConnectionClient.Close()"
  },
  "docs/api/python/api_using_python_with_idea_packages.html": {
    "href": "docs/api/python/api_using_python_with_idea_packages.html",
    "title": "Installing Python (Desktop Environment) | IDEA StatiCa API",
    "keywords": "Python is a simple and powerful programing language that continues to grow in popularity in the AEC industry. All IDEA StatiCa packages are developed on the .NET platform. Using Python.NET the libraries can be accessed and used by Python programmers. Installing Python (Desktop Environment) One of the simplest ways to install Python is using Anaconda. Anaconda automatically installs Python and most of the packages that are used in python programming. It also automatically manages package versions for you! To install Anaconda please follow the instructions here: Installing Python and JupyterLab using Anaconda For those using other Python installs, typical prerequisites for using Python on a desktop environment: Install Python v37 Install Python.NET as it is described on here. Latest versions are strongly recommened (Greater than python .NET 3.0). Code Editors Visual Studio Code Visual Studio Code is a free lightweight code editor that is popular for python developments and provides a range of extensions and tools for developing in Python. Auto-completion in Visual Studio Code - Provides a guide on how to create python stub files for IDEA StatiCa modules to enable auto-completion. Jupyter Lab Jupyter Lab is a tool used by many data scientists and engineers to create documents that can run code in modulated steps. Combined with Pandas data frames and other powerful python visualization modules such as matplotlib this can be an extremely powerful tool. Notepad++ Notepad++ Can also be used to write simple Python code in addition to its many other benefits for text manipulation. GhPython Python code can be run directly in the visual programming tool Grasshopper using the GhPython component. Guide to Getting started with GhPython Referencing the IDEA Libraries Typically required references when working with the IDEA Packages in Python: # Typical Python References import clr import sys import json import math import os Add the path location of the DLLs to the system path. Typically this may be from the IdeaStatiCa installation directory: idea_path = \"C:\\Program Files\\IDEA StatiCa\\StatiCa 21.1\" sys.path.append(idea_path); .Net libraries can then be referenced using the common language runtime (CLR). clr.AddReference('IdeaStatiCa.Plugin') clr.AddReference('IdeaRS.OpenModel') Import required libraries or classes from the modules. from IdeaStatiCa.Plugin import ConnHiddenClientFactory from IdeaRS.OpenModel import OpenModel Examples Create IOM with Python Steel Frame Further Resources Steven Verner has created a Python project to simplify the use of the IDEA StatiCa Plugin API for the optimization of Steel connections. Link to the GitHub repository and instructions on installing. VIKTOR provides a web-based application that allows integration with IDEA StatiCa online apps through a python based environment."
  },
  "docs/bimapi/bimapi_checkbot_link.html": {
    "href": "docs/bimapi/bimapi_checkbot_link.html",
    "title": "| IDEA StatiCa API",
    "keywords": "Background Checkbot is the preferred way to link external third-party applications and allows advanced model data/project management including model syncing, persistent property conversion, and more. To enable a consistent approach to the creation of BIM Links IDEA StatiCa provides a flexible project framework that allows developers to create and distribute their own BIM Links for a third-party application. The following provides information about whether an application is applicable to the Checkbot workflow, the basic features and framework of the application. Linking an Application with Checkbot - Understand how you can connect with Checkbot. Checkbot BIM Link Project Framework - Understand how some of the major Checkbot features work and can be implemented within your project. Example Projects IDEA provides open-source example projects to show how different links are created and integrated with the BimApi: Link Type Description Link RSTAB Link FEA The Rstab link provides the source code of an FEA BIMLink between Rstab and Checkbot. The link is installed to Rstab for execution. view RAM SS Link FEA The RAM Structural Systems link provides the source code of Importing a RAM Structural System Database file into the standalone version of Checkbot. This is a simpler version of a typical BIMLink as it only supports a one-time import of the RAM DB. view"
  },
  "docs/bimapi/bimapi_checkbot_project_framework.html": {
    "href": "docs/bimapi/bimapi_checkbot_project_framework.html",
    "title": "General | IDEA StatiCa API",
    "keywords": "IDEA StatiCa provides a flexible framework for third-party developers to implement advanced Links with a wide range of FEA and CAD applications. The below briefly explains the typical framework of a Checkbot BIM Link as well as some of the features that are available in the current Project framework. The support-center article Checkbot bulk BIM Workflows explains some of these features. General The typical (and preferred) framework for a BIM Link with Checkbot is to enable execution from the base application. This is typically in the form of a button or command from the application. On execution of the command, the Checkbot application will start. A new folder located in the application file directory is created to hold the connection/member files which are generated. If an existing folder already exists, then that project is loaded back into checkbot so the session can continue. As a general rule, the folder that is specified should be generated in a folder where user permission is granted. Object Selection Once Checkbot is opened, the user should select which type of object (nodes or members) they would like to select. If a node is selected, the program will collect all the members connected to that node in order to create the connection. If a member is selected, the program will import only the common nodes of the selected members. Once a selection is confirmed the members and connections are created in IDEAStatica checkbot. At that point, a persistence file in JSON format is written to the folder. Object selection can therefore be executed again at any time to allow the import of more of the structure. The previous object selection should be retained, and the new items merged with the existing selection. This allows for Checkbot to confirm that duplicate members do not get created when importing additional members or joints into Checkbot. To enable object selection, it is required that current selection can be retrieved from the base application. If not, the entire model may need to be sent and selection neglected. Sync Syncing of the Structural model allows updates to the base application model to be synced with the Checkbot project. For example, if a member size is changed in the base application syncing allows for the checkbot application model to be updated. In BIM applications this also applies to connection items such as bolt placements. Syncing Limitations The framework does not provide updating of the base model from changes made in Checkbot or the Connection Files. Import Session and Persistence Material and Property Conversion Checkbot allows for materials and properties (sections, welds, bolt assembly etc.) to be imported from external programs. The developer where possible should decide to create native IOM materials and properties that will be directly created in the Checkbot database. However, in some instances, this is not possible, and the Material or Property can be added ‘By Name’. By default, the IDEA StatiCa library will be searched and if not found will be provided the item to the conversion tab of Checkbot. Refer below for how checkbot manages user-selected conversion. Refer to the IOM Material and IOM Section Property Conversion sections for more info. Conversion Files Conversion files are persistent across the checkbot program and stored locally on a user's machine. This is managed by the checkbot application. Each code has a separate file. Logging and Debugging //To-do"
  },
  "docs/bimapi/bimapi_linking_an_application_with_checkbot.html": {
    "href": "docs/bimapi/bimapi_linking_an_application_with_checkbot.html",
    "title": "Controlling Checkbot from a Third-Party Application | IDEA StatiCa API",
    "keywords": "Below are the seen possible ways of interacting with Checkbot: Controlling Checkbot from a Third-Party Application The most direct method for a user to interact with Checkbot is to allow execution of the Checkbot app from inside a third-party application. Typically, this is achieved by creating a plug-in application that can be installed as a part of the base application. Limitation to this type of interaction: The base application must allow for plug-in Apps to be installed. Being able to retrieve a selection of elements, nodes and connections are generally required also. Before you Start Understand Application Interaction In most cases, someone close to the development of the third-party application will be undertaking the task of creating the BIM Link however, it is important to understand how the application allows for interaction and how this may limit or change the way interaction with Checkbot is to occur: Does the program allow for third-party plug-ins? - The workflow that is explained through this page relies on the ability for a third-party plug-in to be able to be installed within the application. Is there an API? If, so what are the known limitations? - Advanced links Typically rely on a third-party API to interact with the software. If an API is not present a text file conversion to IOM will be required, which is likely to be a one-time export. Is element/node selection available through the API? - Typically the selection of certain parts of the structure is the preferred workflow, but can be worked around. Other questions should include: Does the API use Interfaces or are values extracted as Arrays or Lists? Does the program have multiple applications which need to be closed and opened during the different processes? How does the application manage the persistence of objects? Are results available and how are they provided? What is the database Unit's system and can this be changed? Opening a Third-Party Application from Checkbot The addition of external plug-ins to the Checkbot UI (started from the IDEAStatiCa App) is currently limited to IDEA-developed links only, however, we are looking at enabling a public UI interface in the future. Therefore, it is recommended that an App be created in the manner above so that Checkbot is launched and controlled from within the base application UI. If this type of implementation is in line with a direct import outlined below, a much simpler project framework can be utilized, as syncing is typically neglected for a direct import. The Ram Link project follows this methodology. Currently this Other ways to link/import a Model into Checkbot The Checkbot application can be opened from the main IDEAStatiCa App and currently allows the import of a select few model file types including IOM and the SAF (Structural Analysis format) file types. As per above, additional import options cannot be added by third-party developers currently."
  },
  "docs/extensions/grasshopper/grasshopper_connection_app_components.html": {
    "href": "docs/extensions/grasshopper/grasshopper_connection_app_components.html",
    "title": "IDEA Connection App Components | IDEA StatiCa API",
    "keywords": "IDEA Connection App Components Here we will briefly describe components available to work with IDEA StatiCa Connection files in Grasshopper. The Connection Object Most components relating to the IDEA Connection App allow the passing around of a ‘Connection’ object. The connection object is a reference to an IDEA Connection file saved on disc. First, a user will be required to either reference an existing connection that has previously been create or create one from scratch using the Open Model components. In Grasshopper each ‘Connection’ object is treated as a single connection object. IDEA Connection project files that have multiple connections in the project are separated in Grasshopper and treated as multiple objects with a referenced file path and name. Warning It is encouraged to work with IDEA StatiCa Connection Project files with a single connection. The connection object can also store and manage a duplication of the available information that is extracted from the program. This should be persistent until the connection is modified – which reduces the calls required to the API. Connection Object Components Below is a list of Components which are available to work with the Connection Object. Because users will likely need to work with large amounts of connections at once, components have been added with multiple ways of completing a task which allows us to batch update a single connection at a time rather than by multiple parallel operation. Therefore, there are typically multiple ways to do certain types of tasks. To increase performance, it is encouraged to load as much information when referencing the connection and trying to compile as many modifications into one step as possible if performing modifications. Component Description Reference Connection Reference an existing connection on disc to perform automated operations. When referencing the connection, you can opt to pre-load some of the connection information. This will open the connection and then extract the basic information about the connection. It will likely save you time downstream if you are not performing a lot of modification on the connection object. Create from IOM Create an IDEA Connection File from the IOM Format. A user can either input a file path to an existing model XML file or directly wire the OpenModel object created from the IOM component library. Update from IOM This allows a user to update an existing connection file with a modified IDEA Open Model file. This would typically work in-conjunction with the Extract IOM Container component. Deconstruct The deconstruct component can be used to get general information about the connection object, such as the connection name, file path, and settings etc. Calculate Connection Perform calculation of the connection. Results are read and saved into the Connection Object. If the connection is Modified down the line, results will be wiped from the object. To view the results, pass the connection to the Connection Results Component. The Connection is automatically saved after the calculation has been run. Connection Results Once a connection has been calculated results are stored on the connection object and can be retrieved using the Connection Results component. Results can be filtered by specific keys for different elements. Modify Connection Allow you to make changes to connection items. Refer below for further information. Apply Template Apply a template to a connection using the available template settings. Refer the section on Templates below. Get Connection Geometry Retrieve the geometry of the connection into Grasshopper. This exports the connection and converts to Open Model objects. The Members and Connection Data are exported separately. This component is useful for linking directly with CAD software. Get Connection Costs Allows the user to extract detailed fabrication costs of the connection. Each Cost item can be deconstructed into granular cost items using the Deconstruct Cost item component. Evaluate Expression Evaluate Expression allows you to evaluate expressions. Expressions are typically used in the Parameters interface, however, can also be used directly inside the application. The parameter reference guide provides examples of available parameters. Refer to the Expression Parameters Reference Guide Modifying a Connection Connection modifications are things which will change the ‘design’ of the connection. To reduce the API connection time, we provide a modify connection component which can compile any number of defined modifications and apply them as required in a chronological order. We may separate modification operations in the future when quicker direct linking is possible. The Calculate component also has a modification input to allow performing of modifications prior to calculating. Connection modifications are collated and performed in a Hierarchical order: Update of Library Items* Update of Connection Settings Update of Connection Member Geometry* Update of Connection Operations – By Template (Full) Update of Connection Operations – By Template (Partial) Update of Connection Loading Update of Connection Parameters *Update of these items are not currently possible. Note Currently operations can only be updated through parameters. No direct access to operations exists. Saving vs Save As Any component which performs a modification on the connection file provides the option to either save the connection or save as the connection. To help the user with this process they only need to provide a ‘Save As Suffix’ which will automatically be appended to the existing file in its location. If no suffix is provided the connection will simply be saved with the modification applied. Warning Be careful if you are using a folder to reference all files with a .ideaCon file extension as this can relate in circular referencing if adding additional files to this folder."
  },
  "docs/extensions/grasshopper/grasshopper_connection_item_components.html": {
    "href": "docs/extensions/grasshopper/grasshopper_connection_item_components.html",
    "title": "Connection Item Components | IDEA StatiCa API",
    "keywords": "Connection Item Components Connections items are things in which we may want to extract and then also update in the connection using the Modify Connection component. Item components relate to: Load Effects Parameters Members (Not currently avaliable) Operations (Not currently avaliable) Component Description Deconstruct Item This will deconstruct the item into its properties Modify Item Change properties for an existing item. Note Currently it is not possible to create new or delete existing entities in a connection project. In line with Grasshopper terminology, when a connection item in 'modified' a complete copy of that item is created and then the modifications undertaken. Note Modifications to the connection are not completed until the modified item is passed to the Modifications input. The modification input automatically sorts and collates required modifications. Modifying Load Effects Load Effects can be updated in the connection by selecting a Load Effect from the list output from the Deconstruct Connection component. The Modify Load Effect component uses flat list notion for updating. That means all inputs from Member Id and down need to have the same number of items. First the row is found by providing the Member Id and Position and then each of the provided values is updated. If no value is provided for a row that value is unchanged in the provided load effect. You can change the load effect from an explicit force load effect to a percentage Load effect. When changing, all inputs should be input in as a percentage. You can see the affect of the Percentage input parameter by again deconstructed the updated load Effect. Modify Connection Parameters Using parameters in connection files is one of the most powerful ways to control existing connections and perform optimization procedures. Parameters can be extracted from a connection file using the Deconstruct Connection component. Parameters are extracted as a List of Parameter Sets. Currently a connection will only have one parameter sets and it holds all parameters available in the connection. You can modify parameters in the Parameter set using a Key and Value approach. When deconstructing parameters, you can select whether you want to extract only ‘Visible’ parameters or all the connection parameters. For information on Parameters please refer to the Using Parameters Guide."
  },
  "docs/extensions/grasshopper/grasshopper_connection_object_components.html": {
    "href": "docs/extensions/grasshopper/grasshopper_connection_object_components.html",
    "title": "| IDEA StatiCa API",
    "keywords": "The Connection Object Most components relating to the IDEA Connection App allow the passing around of a ‘Connection’ object. The connection object is a reference to an IDEA Connection file saved on disc. First, a user will be required to either reference an existing connection that has previously been create or create one from scratch using the Open Model components. In Grasshopper each ‘Connection’ object is treated as a single connection object. IDEA Connection project files that have multiple connections in the project are separated in Grasshopper and treated as multiple objects with a referenced file path and name. Warning It is encouraged to work with IDEA StatiCa Connection Project files with a single connection. The connection object can also store and manage a duplication of the available information that is extracted from the program. This should be persistent until the connection is modified – which reduces the calls required to the API. Connection Object Components Below is a list of Components which are available to work with the Connection Object. Because users will likely need to work with large amounts of connections at once, components have been added with multiple ways of completing a task which allows us to batch update a single connection at a time rather than by multiple parallel operation. Therefore, there are typically multiple ways to do certain types of tasks. To increase performance, it is encouraged to load as much information when referencing the connection and trying to compile as many modifications into one step as possible if performing modifications. Component Description Reference Connection Reference an existing connection on disc to perform automated operations. When referencing the connection, you can opt to pre-load some of the connection information. This will open the connection and then extract the basic information about the connection. It will likely save you time downstream if you are not performing a lot of modification on the connection object. Create from IOM Create an IDEA Connection File from the IOM Format. A user can either input a file path to an existing model XML file or directly wire the OpenModel object created from the IOM component library. Update from IOM This allows a user to update an existing connection file with a modified IDEA Open Model file. This would typically work in-conjunction with the Extract IOM Container component. Deconstruct The deconstruct component can be used to get general information about the connection object, such as the connection name, file path, and settings etc. Calculate Connection Perform calculation of the connection. Results are read and saved into the Connection Object. If the connection is Modified down the line, results will be wiped from the object. To view the results, pass the connection to the Connection Results Component. The Connection is automatically saved after the calculation has been run. Modify Connection Allow you to make changes to connection items. Apply Template Apply a template to a connection using the available template settings. Refer the section on Templates below. Get Connection Geometry Retrieve the geometry of the connection into Grasshopper. This exports the connection and converts to Open Model objects. The Members and Connection Data are exported separately. This component is useful for linking directly with CAD software. Get Connection Costs Allows the user to extract detailed fabrication costs of the connection. Each Cost item can be deconstructed into granular cost items using the Deconstruct Cost item component. Evaluate Expression Evaluate Expression allows you to evaluate expressions. Expressions are typically used in the Parameters interface, however, can also be used directly inside the application. The parameter reference guide provides examples of available parameters. Refer to the Expression Parameters Reference Guide Modifying a Connection Connection modifications are things which will change the ‘design’ of the connection. To reduce the API connection time, we provide a modify connection component which can compile any number of defined modifications and apply them as required in a chronological order. We may separate modification operations in the future when quicker direct linking is possible. The Calculate component also has a modification input to allow performing of modifications prior to calculating. Connection modifications are collated and performed in a Hierarchical order: Update of Library Items* Update of Connection Settings Update of Connection Member Geometry* Update of Connection Operations – By Template (Full) Update of Connection Operations – By Template (Partial) Update of Connection Loading Update of Connection Parameters *Update of these items are not currently possible. Note Currently operations can only be updated through parameters. No direct access to operations exists. Saving vs Save As Any component which performs a modification on the connection file provides the option to either save the connection or save as the connection. To help the user with this process they only need to provide a ‘Save As Suffix’ which will automatically be appended to the existing file in its location. If no suffix is provided the connection will simply be saved with the modification applied. Warning Be careful if you are using a folder to reference all files with a .ideaCon file extension as this can relate in circular referencing if adding additional files to this folder."
  },
  "docs/extensions/grasshopper/grasshopper_connection_templates.html": {
    "href": "docs/extensions/grasshopper/grasshopper_connection_templates.html",
    "title": "Connection Template Components | IDEA StatiCa API",
    "keywords": "Connection Template Components Connection templates are files which store complex operation data that can be passed between connections of similar topology. Templates also store any defined connection parameters and other information about the base connection, such as member geometry and sections type. In grasshopper we provide some components which allow the application and deconstruction of IDEA StatiCa template files. Connection Template Object In grasshopper you can reference any number of previously defined templates. Currently only templates saved to disk (as ‘.ideatemp’) are importable in Grasshopper. When a template is imported, we can extract the available parameters that are stored in it. This allows us to understand what parameters will be available in the connection file once the template has been assigned. Note Templates can be exported from base connections using the developer mode in IDEA StatiCa connection. Connection Template Components Below are the components which relate to Connection Templates. Component Description Import Template References an existing ‘.ideatemp’ connection template file which is saved on disc. Deconstruct Template Deconstruct template allows us to deconstruct information that is stored in the template file. Here, it is mainly used to extract the list of parameters that is stored in the template. Full Template Assign Defined a connection template assignment for a template that will be applied to all members in the connection. Here we can provide the template, associated template settings and any modifications to the parameters we would like to apply to the connection once the template has been applied. Partial Template Assign Defined a connection template assignment for a template that will be applied two or more members in the connection. The supporting member plus a list of connection elements. Template Settings Template settings allow for default connection settings to be specified with a template assignment. Assigning a Template The apply template component can be used to assign one or more templates to a connection. Only one full connection template assign should be applied at a time, whereas multiple partials can be applied in succession. Full templates always get set before partial templates. Using template assignments allows us to provide multiple template applications at once using different assign settings. Note To save time, a Template object can also be directly wired into a Template Assign input. When this is done, a full template assign is generated with default settings."
  },
  "docs/extensions/grasshopper/grasshopper_examples.html": {
    "href": "docs/extensions/grasshopper/grasshopper_examples.html",
    "title": "Grasshopper Example Files | IDEA StatiCa API",
    "keywords": "Grasshopper Example Files Examples are currently shipped with the installation files of the plugin. Within the installation folder directory %appdata%\\McNeel\\Rhinoceros\\packages\\7.0 there is a .zip folder: Examples.zip This folder has several workflow examples that are currently possible."
  },
  "docs/extensions/grasshopper/grasshopper_getting_started.html": {
    "href": "docs/extensions/grasshopper/grasshopper_getting_started.html",
    "title": "Getting Started | IDEA StatiCa API",
    "keywords": "Getting Started Program Requirements The plugin is currently developed for Rhino 7. Grasshopper is free and inbuilt into Rhino 7 so there is no need to install grasshopper separately. You can get a trial version of Rhino3d and Grasshopper from the Rhino3d website. Plugin Installation The Plugin can be installed through the Rhino Package Manager. Once installed and Rhino is restarted, the IDEA StatiCa tab will be available in Grasshopper. Plugin Requirements The IDEA StatiCa is built as an extension to the latest versions of IDEA Open Model (IOM) and IDEA API modules. It is recommended when using these tools that the latest version of IDEA StatiCa is installed to work correctly and utilize all the latest features. Limitations Warning Currently for the plugin to work properly, the Rhino Units should be set to meters. Warning All Input Units should also be specified in basic SI units, which follows the IDEA Open Model designation. See Open Model Units specification for more details. Help and Feedback These tools are enhanced with close collabroation with advances users and their required workflows. We are very keen to hear any feedback or suggestions to improve the functionality available. Feedback is best provided through the forum on the IDEA StatiCa public GitHub."
  },
  "docs/extensions/grasshopper/grasshopper_introduction.html": {
    "href": "docs/extensions/grasshopper/grasshopper_introduction.html",
    "title": "Introduction | IDEA StatiCa API",
    "keywords": "Introduction The IDEA StatiCa Grasshopper plugin consists of the following primary parts: Components to generate IDEA Open Model (IOM). These are used to facilitate: Create, Import or Modify IDEA Open Model. Custom FEA Conversions Geometric conversion: IOM <-> Rhino Explicit modelling of members, plates, bolts, cuts, and welds. Components to interact with IDEA Design Applications. The are used to: Create, import, modify design app files, such as connections. Get and update geometry and components. Apply user defined templates. Get and update user defined parameters. Run calculation and extract results. Get further design information (inc. fabrication costs etc.) Components to generate IOM are API agnostic, and therefore do not require a license of IDEA StatiCa. Component that interacts with IDEA StatiCa Design App’s require an active license of IDEA StatiCa. Open Model components are used across Design App components in cases where geometry conversion and interoperability are concerned."
  },
  "docs/extensions/grasshopper/grasshopper_iom_components_overview.html": {
    "href": "docs/extensions/grasshopper/grasshopper_iom_components_overview.html",
    "title": "Open Model Components | IDEA StatiCa API",
    "keywords": "Open Model Components The Open Model Components in Grasshopper allow users to interact flexibly with IDEA Open Model (IOM) in the Grasshopper environment. IDEA Open Model is IDEA StatiCa’s own interoperability framework and open file format. It is defined as a modulated .Net (C#) class structure and used to describe FEA or BIM models and designed and developed to interact natively with IDEA StatiCa Apps. It is good to have a basic understanding on the make-up of IDEA Open Model to understand how the components should work together. For more information on IDEA Open Model please refer to Open Model Documentation. Component Overview There are two primary types of Open Model components: Object Components – Object components relate to creation or modification of modulated Open Model objects that can be then assigned to a Model. Compiling Components – Compiling components relate to compiled models, results or connection data which can be saved and then imported into IDEA StatiCa Apps. These components have assigned databases of assigned objects."
  },
  "docs/extensions/grasshopper/grasshopper_iom_model_components.html": {
    "href": "docs/extensions/grasshopper/grasshopper_iom_model_components.html",
    "title": "Model Components | IDEA StatiCa API",
    "keywords": "Model Components A Model is a compilation of all the single objects that form an entire model with appropriate relative references. An object created by one of the object components is a floating single entity until they are added/assigned to a compiled model. In most instances this relates to an Open Model. Sometimes this will be related to a Compiled Object, however this term is interchangeable between Model or Model Result or any other of the compiled object which are described below. Important Objects need to be assigned to a compiled object before they can be transferred to and from IDEA StatiCa applications. Note Any number of compiled objects can be on the canvas at any one time, making it an extremely flexible way of managing different models and results at the same time. Model Object Components There are five sub-types of components that relate to Open Model component: These are Import, Convert, Create, Deconstruct, Modify, Save, and Inspect. Most of these components also relate to other types of compiled object types such as Open Model Result. Component Type Description Import (XML) This allows you to import an existing saved XML file format of a Compiled Object. You can import the XML definition for several different OpenModel formats. Such as OpenModel, OpenModelResult, OpenModelContainer and ModelBIM. Convert Convert allow direct conversion of some other CAD or FEA formats to IOM directly inside of Grasshopper. Create Create a new OpenModel with your desired settings. Deconstruct Break down a model to see all the assigned objects within it. For a model this is useful to inspect the Members, Materials, Cross-sections within it. Modify Modify a Created or Imported OpenModel. This is the primary component used to add or update objects in a created OpenModel. This is explained in further detail below. Save Save XML allows you to save OpenModel, OpenModelResult, and ModelBIM format to an XML file on disk. Inspect Open Models can also be inspected for the entire XML output of the constructed model. Model Compilation Each time the Model Modify component is run the model is re-compiled. When an object is assigned to a model, a duplicate of the original object is created and assigned to the model database. If the Id and Name of a particular object are not set previously then they are set as required to the copied object. Model compilation is done in a recursive manner, meaning, objects which are required by others are automatically added to the model if they are not already available. For example, if a member is referenced in a connection point, then that member is automatically added to the model, along with the required cross-section and material if it is not already apparent in the model. The image below shows this in practice: Here only the connection point has been provided to the Modify Model component. A validation occurs and automatically adds the required Members along with the cross-sections and relavant materials. Furthermore, if a material is already defined in a Model, then a reference to that object is created. Whenever a model is recompiled, references between different objects are automatically created and the model revalidated. Warning Using this system allows us to reduce the number of required inputs in the Modify Model component. However, it can cause some issues if not careful.It is very important to keep Object Names Unique if they represent different objects. Note Objects which are typically added in a recursive manner generally have required Name inputs - such as Materials, Cross-sections which helps reduce user errors. Modifying a Model The modify component follows typical Grasshopper logic, by first creating a duplicate of the input Model and then updating the duplicate with the provided modifications. Each modify component has inputs for the objects which can be explicity added or updated in the provided model. The input first checks whether the provided object exists in the model (by its Name) and if so, is replaced with the updated object provided. If the object is not present in the model, it is added to the model. The image below demonstrates updating a set of Members and a Connection Point which is already defined in an existing Model. In this instance there is already a list of Members and Connection Points assigned in the Model. Here we want to update the cross-sections of 4 of the existing Members so we provide the Modified Members to the explicit Add/Update input in the Modify Open Model component. The same goes for the Modify Connection Point, where we add additional Plate and Cut information to the existing Connection Point. The same goes for objects assigned to Connection Points (as it is also a compiled object), if an object is already assigned in a connection point, then it will be updated, else it will be added to the connection point. In general, we will likely only want to add things to a connection point. Note Currently objects cannot be deleted from a model"
  },
  "docs/extensions/grasshopper/grasshopper_iom_model_result_components.html": {
    "href": "docs/extensions/grasshopper/grasshopper_iom_model_result_components.html",
    "title": "Open Model Result Components | IDEA StatiCa API",
    "keywords": "Open Model Result Components Open Model Results are used for the storing of analysis results for related analytical members. Using Grasshopper, results in the Open Model Result format can easily be created using the avaliable components. This allows a very flexible way of linking Physical model with analytical FEA model results. Note Refer to documenation on the Open Model Result for internal force designations and explanations on how to create correct Open Model Result files. Creating Open Model Result Creating Open Model Results works in a similar way to other compiled object types. First, the high level object should be created with desired settings, then it can be modified by adding or updating existing entities. The Create Member Loading Result Component can be used to create loading results for a specific member and load case. The Member and Load Case inputs are item inputs which relate to a list of position and internal force results. Typically a mimnimum of two position (begin and end) and force values are to be provided for each member loading result. The output of this component is a list of results were each relates to a member and a result for a particular load case. It has been set up this way to reduce complexitiy in creating results. When the list of these results in passed to the Modify Open Result component these are compiled into combined Memmber 1D results, which are Member results storing all the combined load case data. Note Open Model Results can be saved by using the Save XML component. Using a Reference Model Currently the Open Model Result uses Id values to reference between Members in the Open Model and Open Member results. By providing an optional reference model we can extend this functionality by enabling referencing by further options - such as Name or direct object input. Member and Load Case References When creating Member Loading Results we can take advantage of the Reference Element Component to choose how we want to find related references that are within the Open Model. In the image below the result data references the member and load case by name. We can then set the identifier type to 'Name', which will ensure that the model is searched for a member and load case of that name and ensure the correct referencing."
  },
  "docs/extensions/grasshopper/grasshopper_iom_object_components.html": {
    "href": "docs/extensions/grasshopper/grasshopper_iom_object_components.html",
    "title": "Open Model Object Components | IDEA StatiCa API",
    "keywords": "Open Model Object Components Object components relate to a specific object type in the Open Model data format. Basically, any object which is required to have an Id or Name can be classified as an Open Model Object. Open Model Object Component Types There are five sub-types of components that relate to Open Model objects, these are: Create, Deconstruct, Modify, View, Inspect. Component Type Description Create Creates a new Open Model object of the prescribed type Deconstruct Break down an object into its components and references and provides information about the Object. This typically is useful for imported objects. Modify Modifies a previously created object. Modify components allow certain object properties to be updated. The modify object creates a copy of the object with changed properties. View Provides some different view representations of the object. This only relates to geometric entities. For example the Plate view component can provide this outline, the surface or the volume of the plate. Inspect IOM Objects can be serialised into XML, and to a lesser extent JSON. The Inspect components allows the User to get the XML string representation of any IDEA IOM Object. Object Creation All Open Model Objects are required to have an Id and Name. To make object creation quicker, and to improve usability most objects do not require a user defined id or name on creation, and can be left to be assigned automatically when they are added and compiled to a model. Note Objects that do not have an Id or Name assigned automatically get assigned an Id = 0 and an Empty Name string. When using a Create component the output should show the Name and Id provided to that object. The output string is the Open Model Object Type. Important When creating objects in Grasshopper the object Name should be a Unique string for a particular object type. Note Some specific objects like materials, cross-sections, load cases and combinations do require a name on object creation."
  },
  "docs/extensions/grasshopper/grasshopper_overview.html": {
    "href": "docs/extensions/grasshopper/grasshopper_overview.html",
    "title": "IDEA StatiCa Grasshopper | IDEA StatiCa API",
    "keywords": "IDEA StatiCa Grasshopper The following section looks to introduce and provide information on the IDEA StatiCa plugin for Grasshopper3d, a visual programming package attached to the powerful modelling CAD software Rhino3d. Rhino and Grasshoppper is an powerful CAD modelling platform with a large array of plugins avaliable for the Architectural and Engineering industry. Combining Grasshopper with IDEA StatiCa's Open Model and API's creates an extremely powerful platform for the parametric definition of complex connection geometry plus the automation and optimisation of connections. Caution The Rhino/Grasshopper plugin for Grasshopper3d is currently WORK IN PROGRESS. Therefore, use it with care. We cannot currently guarantee compatibility between each version, as the development continues to progress."
  },
  "docs/iom/iom_connection_materials_and_products.html": {
    "href": "docs/iom/iom_connection_materials_and_products.html",
    "title": "| IDEA StatiCa API",
    "keywords": "WIP: 👷‍♂️ Needs testing and confirmation. This page is excluded from documentation as it is not implemented correctly in IOM Bolt Grades A bolt grade can now be added to IOM using the MaterialBoltGrade class. In most instances, you may want to reference a library-defined bolt grade from the IDEA StatiCa Library. This can be done using a similar method to other materials. Where a specific code BoltGrade Material is not provided make sure to set the code parameter on the bolt grade. public static void Example_AddMaterialBoltGrade(OpenModel openModel, CountryCode code) { if (code == CountryCode.Australia) { //Define Name Australian bolt grade to Reference //Set Load From Library MaterialBoltGrade boltGrade = new MaterialBoltGrade { Name = \"8.8\", LoadFromLibrary = true, Code = CountryCode.Australia }; openModel.AddObject(boltGrade); } } Bolt Assemblies A bolt assembly can now be added to IOM using the BoltAssembly class: A bolt assembly can be referenced to a BoltGrid or AnchorGrid by specifying the BoltAssembleyName parameter on the respective objects. Refer connection data pages. Weld Electrode / Grade Currently, weld electrodes and materials relating to welds are defined as a steel material and referenced to a weld by Name."
  },
  "docs/iom/iom_connection_point.html": {
    "href": "docs/iom/iom_connection_point.html",
    "title": "| IDEA StatiCa API",
    "keywords": "Status: 👷‍♂️ Work In Progress. Have a question relating to the topic? Please add an issue. Beams This data extends the properties of Design Members in the Structural Model for the purpose of designing a Connection. You can specify: Whether a beam is a Structural Member (loaded) or an Added Member (part of a Connection design, e.g. Cleats used to bolt Structural Members together) That a given Beam is Bearing, meaning that supports will be added in the model of the Connection Whether a beam is negative, meaning that it is only used to generate cuts and cut-outs on the other Beams Added Members Added Members are additional structural items that relate to a particular connection. Some examples are stiffening members or angle cleats. Although typically relating to a single connection, added Members are references to Member1D's in the Open Model. Therefore, they need to be defined and added to the OpenModel as a Member1D (I.e by defining start/endpoints, LCS, and cross-section). Once defined in the OpenModel, added members can be added to a specific connection ConnectionData as Beam Data with the IsAddedMember property set to true. The members should also be added to the ConnectionPoint ConnectedMembers` list as well. The example below shows how the set the BeamData of an added member. public static void Example_AddAddedMember(OpenModel openModel, int openModelMemberId) { //Reference Data Connection that has been defined in the OpenModel ConnectionData connectionData = openModel.Connections[0]; BeamData addedMemberData = new BeamData(); //Set the beam data as an Added Member addedMemberData.IsAdded = true; //Reference previously created Member1D in the openModel addedMemberData.AddedMember = new ReferenceElement(openModel.Member1D.FirstOrDefault(x => x.Id == openModelMemberId)); //Set Beam Data Id addedMemberData.Id = connectionData.Beams.Count + 1; connectionData.Beams.Add(addedMemberData); } Negative Volumes WiP Plates Plates can now be defined using Region2D property. Defining plates using an SVG string property is now obsolete. Cuts WiP Welds WiP Bolt Grids WiP Anchors WiP Concrete Blocks WiP"
  },
  "docs/iom/iom_coordinate_systems.html": {
    "href": "docs/iom/iom_coordinate_systems.html",
    "title": "Global Coordinate System | IDEA StatiCa API",
    "keywords": "As a general rule, you can consider all coordinate systems used are right-handed. Global Coordinate System All elements and nodes are defined in a standard cartesian axis system with the z-axis vertical: The X-axis of the global coordinate system is horizontal and reads from left to right. The Y-axis is horizontal and reads from bottom to top. The Z-axis of the global coordinate system is vertical and leads upwards. Local Coordinate Systems 1D Members Each 1D member is defined by a start and end node and has a local coordinate system defined in the following way: Origin is defined as the start node of the member. The local x-axis follows the member axis, oriented from the start to the end node. The local y-axis of the member is horizontal in general. The local z-axis leads upwards and is the normal of the 1D member. Define 1D member coordinate systems It is important to pay attention to the correct setting of coordinate systems of 1D members. This is especially the case when converting from FEA models applications as it can cause unbalanced internal forces in exported connections. The coordinate system of a member is a property of Segment3D. There are 3 options how to define the Segment3D coordinate system within the 1D Member: CoordSystemByPoint CoordSystemByPoint Defining a coordinate system by point allows you to define a reference point in the model to orient the local coordinate system of the member. You can specify which member plane will be the plane that will be aligned with the selected point. You typically may want to either use Plane.ZX or Plane.YX. Using Plane.ZX will rotate the Coordinate system around the member x-axis so that the member normal (z-axis) is in the direction of the specified point. LineSegment3D segment3D = new LineSegment3D(); segment3D.StartPoint = new ReferenceElement(model.Point3D.FirstOrDefault(item => item.Name == startNode)); CoordSystemByPoint system = new CoordSystemByPoint(); system.Point = new Point3D() { X = 100000, Y = 0, Z = 0 }; system.InPlane = Plane.ZX; segment3D.LocalCoordinateSystem = system; This is typically used for vertical elements. CoordSystemByvector CoordSystemByVector CoordSystemByZup CoordSystemByZup The coordinate system by Z up aligns the member local z-axis (as close as possible) to the global Z-axis up direction: This is the default option for non-vertical members. For vertical members x-axis (member axis) is vertical then the y-axis local follows the global Y-axis. 1D Member Eccentricities Eccentricities (or offsets) specify a local vector translation from the Element1D start and end nodes. Eccentricities are specified in the local coordinate system through the respective 'Element1D' properties. 1D Member Rotations Rotations of the Cross-section around the LCS are completed through the Element1D RotationRx property. Rotations follow a right-hand rule system around the member local x-axis direction. Coordinate system of cross-section Cross-sections have reference axes y (horizontal) and z (vertical). Principal axes of the cross-section are marked with u and v. If reference axes are identical with the main central axes of cross-section, only reference axes are drawn. By default, cross-sections are applied to Member 1Ds with the reference axis aligning with the coordinate system of the member. Cross-section rotations Cross-sections can be rotated prior to being applied to the local coordinate system of the member. Follow a right-hand rule system based on the x-axis being up (facing out-of-page) of the page local x-axis direction. Convention of internal forces on 1D members Convention of internal forces in IDEA StatiCa structural model is summarized on the following six sets of examples. Normal force N Positive (+N) normal force causes tension. Negative (-N) normal force causes compression. Axial load [X] Resulting normal force [N] diagram Effects of the normal force [N] on a beam element Shear force Vy Positive (+Vy) shear force shifts the left face in the positive Y axis direction. Continuous load [Y] Resulting shear force [Vy] diagram Effects of the shear force [Vy] on a beam element Shear force Vz Positive (+Vz) shear force shifts the left face in the positive Z axis direction. Continuous load [Z] Resulting shear force [Vz] diagram Effects of the shear force [Vz] on a beam element Torsion Mx Positive (+Mx) torsion twists the left face counterclockwise. Point load [Mx] Resulting torsion [Mx] diagram Effects of the torsion [Mx] on a beam element Bending moment [My] Positive (+My) bending moment causes tension the fibers with a negative Z coordinate. Continuous load [Z] Resulting bending [My] diagram Effects of the bending [My] on a beam element Bending moment [Mz] Positive (+Mz) bending moment causes tension the fibers with a negative Y coordinate. Continuous load [Y] Resulting bending [Mz] diagram Effects of the bending [Mz] on a beam element Convention of load effects in the Connection app The load effects input on the connected beams in the Connection app follow the LCS axes. As a beam can either be connected by its startpoint or endpoint, the load effects directions change accordingly. Visualization of the load effect convention in the Connection app The positive (+) force components act in positive directions of LCS axes. Beam connected by endpoint (left) and startpoint (right): The positive (+) moment components strictly follow the right-hand rule. Beam connected by endpoint (left) and startpoint (right): Conversion between the structural model results and Connection app load effects As a result of both the conventions documented above, there is a transformation of internal force results to load effects taking place internally. This transformation happens every time a connection project is created on the basis of a structural model. Internal force vector {N, Vy, Vz, Mx, My, Mz} Startpoint (relative position = 0) Tranformation to load effects {+1, -1, -1, +1, -1, +1} Endpoint (relative position = 1) Tranformation to load effects {-1, +1, +1, -1, +1, -1} Consider the example of two cantilevers below. One is supported in the standpoint (relative position 0), the other in the endpoint (relative position 1). Internal forces in the fixed points of the cantilevers are {1, 0, 1, 0, -1, 0} and {1, 0, -1, 0, -1, 0}, respectively. When connections are generated in these points, the transformation vector above is applied, with the following results. Load effects in the fixed points of the cantilevers are {1, 0, -1, 0, 1, 0} and {-1, 0, -1, 0, -1, 0}, respectively. Comparing the deformed shapes of the connections above, their behaviour confirms the correct transformation and is in accordance with the structural model."
  },
  "docs/iom/iom_cross_sections.html": {
    "href": "docs/iom/iom_cross_sections.html",
    "title": "Adding Cross-Section Properties to IOM Open Model | IDEA StatiCa API",
    "keywords": "Adding Cross-Section Properties to IOM Open Model This example demonstrates how to add section properties to an IOM model using the IdeaRS.OpenModel.CrossSection.CrossSectionFactory class. The CrossSectionFactory class provides a list of methods to populate a CrossSectionParameter with the correct parameters and section types available in IDEAStatiCa. Although most, not all cross-section definitions in IOM are defined using the CrossSectionFactory. Refer below for which cross-section types this applies. Current Limitations There is no method in the CrossSectionFactory which allows quick creation of a 'Standard' Section. I.E the manual creation of the 'UniqueValue' parameter needs to be specified. Note that IDEAStatiCa breaks standard sections into plates and therefore does not take into consideration a small radius in sections. Therefore any type of 'standard' section can be represented as a welded plate cross-section. This also includes sections that are to be referenced from the IDEAStatiCa Section library. Use the 'UniqueName' parameter to reference. Library Shapes Below indicates how should be used to generate sections as per the Rolled Sections tab in IDEAStatiCa Cross-Section Navigator. using IdeaRS; using IdeaRS.OpenModel.Material; using IdeaRS.OpenModel.CrossSection; using IdeaRS.OpenModel.Geometry2D; --- public static void Example_AddLibraryCrossSection(OpenModel openModel) { CrossSectionParameter cs = new CrossSectionParameter() { Id = 1, Name = \"myLibrarySection\" }; MatSteel material = openModel.MatSteel.First(); cs.Material = new ReferenceElement(material); cs.CrossSectionType = CrossSectionType.UniqueName; cs.Parameters.Add(new ParameterString() {Name = \"UniqueName\", Value = \"HEB200\"}); openModel.AddObject(crossSectionParameter); } Section Conversion To convert a Libary shape in one application to a Libary shape in IDEAStatiCa, you can either: Manage conversions through the Checkbot App. (Recommended) Create your own conversion table sets within your conversion code. The Checkbot App allows you to manage the shapes which were not able to be automatically converted into IDEAStatiCa. You can select an appropriate section for these non-converted shapes through the conversion options which are available after import. To ensure a section is created, provide a 'UniqueName' parameter to the cross-section (similar to the Library example above). On import, IDEAStatiCa will attempt to find the cross-section within the available Libraries. If not found it will be added to the conversion options list. Managing Not-Implemented Sections in IOM If a shape is not available to be currently defined, a 'UniqueName' section can be generated in order to provide a placeholder for the section. On import, IDEAStatiCa will attempt to find the section within the available Libraries. The Checkbot conversion options can then be used to apply the correct section from within IDEA. Parametric Shapes Cross-sections that are generated from 'parameters' alone (not regions or lines) are of the CrossSectionParameter class. The CrossSectionParameter object is created and then passed to the CrossSectionFactory to be filled with all the required parameters of a particular shape. The example below is for an I section shape cross-section can be generated as below: public static void Example_CreateAndAddCrossSection(OpenModel model) { CrossSectionParameter crossSectionParameter = new CrossSectionParameter() { Id = 1, Name = \"myISection\" }; MatSteel material = model.MatSteel.First(); crossSectionParameter.Material = new ReferenceElement(material); CrossSectionFactory.FillCssIarc(crossSectionParameter, 0.25, .045, 0.02, 0.03, 0.012, 0, 0.015); model.AddObject(crossSectionParameter); } Rolled Sections Below indicates which CrossSectionFactory method should be used to generate sections as per the Rolled Sections tab in IDEAStatiCa Cross-Section Navigator. In the IDEAStatiCa connection, rolled cross-sections are broken up into separate plate elements for FEA calculation. Radi and tapers are neglected in this step, hence in many cases rolled sections can also be defined using the Welded/Composed methods. IDEA Shape Ref Image Factory Method CrossSectionFactory. Notes Circular FillCircle(...) General Plate FillRectangle(…) I FillCssIarc(…) For asymmetric I-sections the FillWeldedAsymI(…) can be used. Channel FillCssSteelChannel(…) Angle FillCssSteelAngle(…) General Tube .FillCHSPar(…) / FillSteelTube(…) T (I Cut) FillSteelTI(…) This requires the Name of an IDEAStatiCa Library I section. Additional Square Hollow FillCssSteelRectangularHollow(…) Welded, Composed Cross-Sections Below indicates which CrossSectionFactory method should be used to generate sections as per the Rolled Sections tab in IDEAStatiCa Cross-Section Navigator. IDEA Shape Ref Image Factory Method CrossSectionFactory. Notes 2I Not Implemented 2Uo FillShapeDbLU(…) You need to specify section shapes manually for this method. 2Uc FillWelded2Uc(…) This method requires the Name of an IDEAStatica Library Channel. 2Lt FillWelded2Lt(…) This method requires the Name of an IDEAStatica Library Angle. 2Lu FillWelded2Lu(…) This method requires the Name of an IDEAStatica Library Angle Iw FillWeldedI(…) Iwn FillWeldedAsymI(…) This item can be used to define a asymmetric ‘rolled’ I section. Tw FillWeldedT(…) Box FI FillBox2(…) Box Web Not Implemented Define this using the CrossSectionComponent class Box 2I Not Implemented Box 2U FillWelded2Uc(…) Set 'distance' parameter to zero. Box 2L Not Implemented Box 4L Not Implemented Box Delta Not Implemented Define this using the CrossSectionComponent class Box Triangle Not Implemented Define this using the CrossSectionComponent class General Steel Does not use CrossSectionFactory Define this using the CrossSectionComponent class. An example is show below. Creating a General Welded Cross-Section Creating a general steel cross-section, i.e one that is made up of a number of components. (i.e plates or other items) requires the use of the CrossSectionComponent class. This object can store a number of CssComponent's. Note: You cannot currently add CrossSectionParam objects to a CrossSectionComponent. Each plate will need to be specified individually and has its own material and phase. The example below creates a custom T-shape arrangement as shown below. public static void Example_CreateComponentCrossSection(OpenModel openModel) { CrossSectionComponent componentCrossSection = new CrossSectionComponent() { Id = 1, Name = \"myComponentCrossSection\" }; //Component 1 CssComponent comp1 = new CssComponent() { Material = new ReferenceElement(openModel.MatSteel.First()), Phase = 0 }; Region2D region = new Region2D(); PolyLine2D outline = new PolyLine2D(); outline.StartPoint = new Point2D() { X = 0, Y = 0 }; outline.Segments.Add(new LineSegment2D() { EndPoint = new Point2D() { X = 0.2, Y = 0 } }); outline.Segments.Add(new LineSegment2D() { EndPoint = new Point2D() { X = 0.2, Y = -0.015 } }); outline.Segments.Add(new LineSegment2D() { EndPoint = new Point2D() { X = 0, Y = -0.015 } }); outline.Segments.Add(new LineSegment2D() { EndPoint = new Point2D() { X = 0, Y = 0 } }); region.Outline = outline; comp1.Geometry = region; componentCrossSection.Components.Add(comp1); //Component2 CssComponent comp2 = new CssComponent() { Material = new ReferenceElement(openModel.MatSteel.First()), Phase = 0 }; region = new Region2D(); outline = new PolyLine2D(); outline.StartPoint = new Point2D() { X = 0.095, Y = -0.015 }; outline.Segments.Add(new LineSegment2D() { EndPoint = new Point2D() { X = 0.105, Y = -0.015 } }); outline.Segments.Add(new LineSegment2D() { EndPoint = new Point2D() { X = 0.105, Y = -0.14 } }); outline.Segments.Add(new LineSegment2D() { EndPoint = new Point2D() { X = 0.095, Y = -0.14 } }); outline.Segments.Add(new LineSegment2D() { EndPoint = new Point2D() { X = 0.095, Y = -0.015 } }); region.Outline = outline; comp2.Geometry = region; componentCrossSection.Components.Add(comp2); openModel.AddObject(componentCrossSection); } Cold Formed CrossSections Below indicates which CrossSectionFactory method should be used to generate sections as per the Cold-formed sections tab in IDEAStatiCa Cross-Section Navigator. IDEA Shape Ref Image Factory Method CrossSectionFactory. Notes CF Omega .FillColdFormedOmega(…) CF C .FillColdFormedC(…) CF C+ Not Implemented CF L .FillColdFormedL (…) CF Lgen .FillColdFormedLgen(…) CF Z .FillColdFormedZ(…) CF Regular Polygon .FillColdFormedRegularPolygon(…) CF Sigma .FillColdFormedSigma(…) CF U .FillColdFormedChannel(…) CF ZED .FillColdFormedZed(…) CF RHS .FillColdFormedRHS(…) General Tube .FillSteelTube(…) CF 2Co Not Implemented CF 2C+o Not Implemented CF General Shape .FillColdFormedGeneral(…) The general cold-formed section is not a parametric section and therefore has its own class, CrossSectionGeneralColdFormed to store the polyline which defines its shape. Refer below for an example. The example below show how to generate a General cold-formed section. public static void Example_CreateAndAddColdFormedGeneralCrossSection(OpenModel openModel) { CrossSectionGeneralColdFormed coldFormedSection = new CrossSectionGeneralColdFormed() { Id = 1, Name = \"myColdFormedSection\" }; MatSteel material = openModel.MatSteel.First(); coldFormedSection.Material = new ReferenceElement(material); Region2D region = new Region2D(); PolyLine2D outline = new PolyLine2D(); outline.StartPoint = new Point2D() { X = 0, Y = 0 }; LineSegment2D seg = new LineSegment2D(); seg.EndPoint = new Point2D() { X = 0.050, Y = 0.050 }; outline.Segments.Add(seg); seg = new LineSegment2D(); seg.EndPoint = new Point2D() { X = 0.1, Y = 0.050 }; outline.Segments.Add(seg); seg = new LineSegment2D(); seg.EndPoint = new Point2D() { X = 0.15, Y = 0.000 }; outline.Segments.Add(seg); region.Outline = outline; double thickness = 0.003; double innerRadius = 0.005; CrossSectionFactory.FillColdFormedGeneral(coldFormedSection, region, thickness, innerRadius); openModel.AddObject(coldFormedSection); } Timber Sections Timber shapes are currently not implemented in IOM. Concrete Sections Below indicates which CrossSectionFactory method should be used to generate concrete sections as per the IDEAStatiCa Cross-Section Navigator. IDEA Shape Ref Image Factory Method CrossSectionFactory. Notes Rectangular FillRectangle(…) Circular FillCircle(…) I Shape FillShapeI(…) T Shape FillShapeT(…) T Shape Reverse .FillShapeTrev(…) L Shape FillShapeL(…) L Shape Mirror Not Implemented S Shape Not Implemented Z Shape Not Implemented U Shape FillShapeU(…) U Shape Reverse Not Implemented Use FillShapeU(...) and flip the LCS Rectangular Hollow FillCssRectangleHollow(…) Circular Hollow FillOHollow(…) Oval Shape Not Implemented I Shape with Haunched Flanges FillShapeIBase(…) T Shape with Champfer Not Implemented T Shape with Haunched Wall and Chamfer Not Implemented Trapezoidal Shape FillShapeTrapezoid1(…) T Shape with Haunched Flanges Not Implemented Use FillShapeTrev1(...) and flip LCS. T Shape with Haunched Wall FillShapeTwh(…) Inverted T Shape with Haunched Flanges .FillShapeTrev1(…) Inverted T Shape with Haunched Wall Not Implemented Use FillShapeTwh(…) and flip LCS. Double T Shape .FillShapeTT(…) Double T Shape with Chamfers Not Implemented Hollow Cross Section 1 Not Implemented Use method for General Concrete Section Hollow Cross Section 2 Not Implemented Use method for General Concrete Section Asymetrical I Shaped Not Implemented Use method for General Concrete Section Slab on Trapezoidal Sheet Not Implemented Slab on Trapezoidal Sheet Negative .*Not Implemented* | General Concrete Section | Does not use CrossSectionFactory| Define this using theCrossSectionComponent` class. An example is shown below. The example below shows how to generate a General concrete section with an opening. public static void Example_CreateConcreteComponentCrossSection(OpenModel openModel) { //Concrete material MatConcreteEc2 mat = new MatConcreteEc2(); //... openModel.AddObject(mat); //Cross-section without the bars //One component square 0.8x0.8m IdeaRS.OpenModel.CrossSection.CrossSectionComponent css = new IdeaRS.OpenModel.CrossSection.CrossSectionComponent(); css.Name = \"CSS1\"; //Component of cross-section CssComponent comp = new CssComponent(); comp.Material = new ReferenceElement(mat); comp.Phase = 0; //Geometry of component 0.8x0.8 Region2D region = new Region2D(); PolyLine2D outline = new PolyLine2D(); outline.StartPoint = new Point2D(); outline.StartPoint.X = -0.04; outline.StartPoint.Y = -0.04; LineSegment2D seg = new LineSegment2D(); seg.EndPoint = new Point2D(); seg.EndPoint.X = 0.04; seg.EndPoint.Y = -0.04; outline.Segments.Add(seg); seg = new LineSegment2D(); seg.EndPoint = new Point2D(); seg.EndPoint.X = 0.04; seg.EndPoint.Y = 0.04; outline.Segments.Add(seg); seg = new LineSegment2D(); seg.EndPoint = new Point2D(); seg.EndPoint.X = -0.04; seg.EndPoint.Y = 0.04; outline.Segments.Add(seg); seg = new LineSegment2D(); seg.EndPoint = new Point2D(); seg.EndPoint.X = -0.04; seg.EndPoint.Y = -0.04; outline.Segments.Add(seg); region.Outline = outline; //Optional - setting openning in this component 0,2x0,2 PolyLine2D openning = new PolyLine2D(); openning.StartPoint = new Point2D(); openning.StartPoint.X = -0.01; openning.StartPoint.Y = -0.01; seg = new LineSegment2D(); seg.EndPoint = new Point2D(); seg.EndPoint.X = -0.01; seg.EndPoint.Y = 0.01; openning.Segments.Add(seg); seg = new LineSegment2D(); seg.EndPoint = new Point2D(); seg.EndPoint.X = 0.01; seg.EndPoint.Y = 0.01; openning.Segments.Add(seg); seg = new LineSegment2D(); seg.EndPoint = new Point2D(); seg.EndPoint.X = 0.01; seg.EndPoint.Y = -0.01; openning.Segments.Add(seg); seg = new LineSegment2D(); seg.EndPoint = new Point2D(); seg.EndPoint.X = -0.01; seg.EndPoint.Y = -0.01; openning.Segments.Add(seg); region.Openings.Add(openning); comp.Geometry = region; css.Components.Add(comp); openModel.AddObject(css); } Non-symetrical Cross-sections. A simple explanation of the IOM Co-ordinate system can be found here. Here we will the preferred method of dealing with non-symmetrical section shapes. Asymmetrical cross-sections are those with one axis of symmetry. (i.e I beam with different flange widths). These have two possible orientations. Unsymmetrical cross-sections are those with no axis of symmetry. (i.e Angle section). These of which have four possible orientations. Note: The below applies primarily to Steel cross-sections. Some Concrete sections do have CrossSectionFactory methods which can directly generate the inverted/reverse version without requiring resetting of the member LCS. Option A Option B Option C Option D Base shape Base shape mirrored (using mirrored param in CrossSectionFactory method) Base shape with Local Co-ordinate system of Member reversed when setting Base shape mirrored and Local Co-ordinate system of Member reversed when setting."
  },
  "docs/iom/iom_geometry.html": {
    "href": "docs/iom/iom_geometry.html",
    "title": "| IDEA StatiCa API",
    "keywords": "This page visualizes the process of generating the Geometry of a structure through the IOM. Points 3D Points3D are the base constituents of IOM Geometry. They are used to define Segments3D, and also Connection Points later on, which may or may not coincide with Segment3D start and endpoints. Point3D is defined by an Id, a Name, and coordinates in 3D space: Segments 3D There are either linear or arc segments. This example deals with simple linear Segments3D. Each LineSegment3D is defined by its StartPoint, EndPoint, and a Local Coordinate System. This LCS then controls the cross-section positioning, as well as internal force results definition. Elements 1D Elements enrich the information contained in Segments 3D by adding the information about Cross-sections. Please note that in order to define an Element 1D, you first need to define a Material, then a Cross-section, then combine this data with an appropriate Segment3D. Start and End eccentricities are also possible to set in this stage. Members 1D Members1D no longer add new information, they are simply collections of Elements1D. In most cases, a single Element1D is used in each Member1D. Assigning multiple Elements1D under one Member1D is effectively making them continuous, as can be seen on the image below: Connection Point After the necessary geometry has been defined, you can generate a ConnectionPoint by defining a Point 3D, and a collection of Members 1D. Structural Model and Connection Model You can see the resulting Structural Model that is generated based on the IOM in the background (or displayed in the Checkbot app), as well as the Connection Model in the Connection app side by side. Please note the Points, Members, their Cross-sections and Local Coordinate Systems."
  },
  "docs/iom/iom_getting_started.html": {
    "href": "docs/iom/iom_getting_started.html",
    "title": "Getting Started with IDEA Open Model | IDEA StatiCa API",
    "keywords": "Getting Started with IDEA Open Model What is IDEA OpenModel The OpenModel class OpenModel is the high-level class that holds all the information required for CAD or FEA model transfer (except model results). Information is stored in Lists of separate lists for different object types. To start creating a Model definition, create a new OpenModel. OpenModel model = new OpenModel(); OpenElementId Each class that is placed into a Type list contained in the OpenModel object inherits from the OpenModel base class object, OpenElementId. The OpenElementId has one property 'Id' which all concrete classes inherit. This Id is an Integer and must be greater than 0 when added to the appropriate list in the OpenModel. Adding Elements to Open Model If you do not care about the Id which is assigned to the OpenElementId object when adding to a list you can automate the Id selection by using the AddObject() method on the OpenModel object. int assignedId = openModel.AddObject(myIOMObject); You can also get the highest Id of all objects in a particular list by using the 'GetMaxId()' method on the OpenModel object. Add 1 to get the next available in the list. int nextAvaliableId = openModel.GetMaxId(myIOMObject) + 1; Reference Elements Reference Elements are used to make references between different Type lists in the Model. A classic example is a Cross-section needing to reference a Material from the Material List. Reference Elements can either be created by a concrete object or simply by providing the Id and Object Type."
  },
  "docs/iom/iom_loading.html": {
    "href": "docs/iom/iom_loading.html",
    "title": "Load Cases | IDEA StatiCa API",
    "keywords": "Load Cases Load Cases are the basic entities for which the internal force results are defined. Load Cases can be used directly to generate Load Effects on a Connection, or they can be added together to generate Load Combinations. Apart from the Load Case name, there are several important properties: Load Group - please see the next paragraph Load Case Type (Permanent, Variable, Accidental, Nonlinear) Load Groups Load Groups group Load Cases together and define their behaviour when assigned under a Load Combination. Apart from the Load Group name, there are the following properties you need to specify: Load Group Type (Permanent, Variable, Accidental, Fatigue, Seismic) Relation (Standard, Exclusive, Together) - please see the Load Combinations paragraph to learn about the consequences of this property Load Combinations Load Combinations can be used to combine multiple Load Cases together to act simultaneously and then used to generate Load Effects on a Connection. You can define the Combination name and Description, which is informative. The important properties are: Combination Items (Load Cases with appropriate combination coefficients) Combination Type (limit state - ULS or SLS) Combination Calculation Type (Evaluation type - Linear or Envelope) Linear Combination will simply add the specified Load Cases. Envelope Combination will take the Load Groups and their Relation into account, and generate multiple Linear Combinations accordingly in the background."
  },
  "docs/iom/iom_materials.html": {
    "href": "docs/iom/iom_materials.html",
    "title": "Materials | IDEA StatiCa API",
    "keywords": "Materials All materials in IOM derive from the Material base class. Materials are then defined by a Type Class (Steel, Concrete, Reinforcement) and then by country (EC, US, AUS). All materials in an OpenModel MUST reference the same Country Code. To ensure this it is best to pass the IOM Open Model Settings Model Country Code on the creation of materials. Library Materials IDEA StatiCa has a library of materials that can be searched for without the requirement to specify all material information in the code. Make sure the name exactly matches that of the material name in IDEA StatiCa. The material type and material code also need to be created correctly. If the material is not found in the IDEA Database the name will be created with default properties provided. public static void Example_AddLibraryMaterialSteel(OpenModel openModel, CountryCode code) { if (code == CountryCode.American) { //Define Name as an American Steel to Reference //Set Load From Library MatSteelAISC steelAISC = new MatSteelAISC() { Name = \"A36\", LoadFromLibrary = true }; openModel.AddObject(steelAISC); } //Switch between other codes as required. } Steel Materials Steel Materials for different codes have differing parameters for creation. Although, still a lot share common parameters as well. The below shows how to create a Eurocode Steel Material. public static void Example_UserMaterialSteelECEN(OpenModel openModel, CountryCode code) { if (code == CountryCode.ECEN) { MatSteelEc2 matS = new MatSteelEc2(); matS.Name = \"S275\"; matS.UnitMass = 7850.0; matS.E = 200e9; matS.Poisson = 0.2; matS.G = 83.333e9; matS.SpecificHeat = 0.6; matS.ThermalExpansion = 0.00001; matS.ThermalConductivity = 45; matS.fy = 235e6; matS.fu = 360e6; matS.fy40 = 215e6; matS.fu40 = 340e6; matS.StateOfThermalConductivity = ThermalConductivityState.Code; matS.StateOfThermalExpansion = ThermalExpansionState.Code; matS.StateOfThermalSpecificHeat = ThermalSpecificHeatState.Code; matS.StateOfThermalStressStrain = ThermalStressStrainState.Code; matS.DiagramType = SteelDiagramType.Bilinear; } openModel.AddObject(matS); } Concrete Materials The below shows an example of how to create a Eurocode Concrete Material. public static void Example_CreateAndAddUserMaterialConcreteWithDiagram(OpenModel openModel, CountryCode code) { if (code == CountryCode.ECEN) { MatConcreteEc2 mat = new MatConcreteEc2(); mat.Name = \"Concrete1\"; mat.UnitMass = 2500.0; mat.E = 32.8e9; mat.G = 13.667e9; mat.Poisson = 0.2; mat.SpecificHeat = 0.6; mat.ThermalExpansion = 0.00001; mat.ThermalConductivity = 45; mat.Fck = 25.5e6; mat.CalculateDependentValues = true; //Set s-s diagram as a default parabolic mat.DiagramType = ConcDiagramType.Parabolic; //Set s-s diagram as an user defined mat.DiagramType = ConcDiagramType.DefinedByUser; var userDiagram = new Polygon2D(); mat.UserDiagram = userDiagram; userDiagram.Points.Add(new Point2D() { X = -0.021, Y = 0 }); userDiagram.Points.Add(new Point2D() { X = -0.02, Y = 0 }); userDiagram.Points.Add(new Point2D() { X = -0.0025, Y = -80000000 }); userDiagram.Points.Add(new Point2D() { X = -0.0024, Y = -79868660.43 }); userDiagram.Points.Add(new Point2D() { X = -0.0023, Y = -79461961.9 }); userDiagram.Points.Add(new Point2D() { X = -0.0022, Y = -78762709.44 }); userDiagram.Points.Add(new Point2D() { X = -0.0021, Y = -77756658.69 }); userDiagram.Points.Add(new Point2D() { X = -0.0019, Y = -74785483.74 }); userDiagram.Points.Add(new Point2D() { X = -0.0017, Y = -70514061.33 }); userDiagram.Points.Add(new Point2D() { X = -0.0015, Y = -64981949.46 }); userDiagram.Points.Add(new Point2D() { X = -0.001, Y = -46511627.91 }); userDiagram.Points.Add(new Point2D() { X = -0.0005, Y = -23904382.47 }); userDiagram.Points.Add(new Point2D() { X = 0, Y = 0 }); userDiagram.Points.Add(new Point2D() { X = 0.001, Y = 0 }); //Setting thermal characteristcs of material (in this case by the code) mat.StateOfThermalConductivity = ThermalConductivityState.Code; mat.StateOfThermalExpansion = ThermalExpansionState.Code; mat.StateOfThermalSpecificHeat = ThermalSpecificHeatState.Code; mat.StateOfThermalStressStrain = ThermalStressStrainState.Code; openModel.AddObject(mat); } } Timber Materials Timber materials cannot currently be defined through the IOM."
  },
  "docs/iom/iom_model_settings.html": {
    "href": "docs/iom/iom_model_settings.html",
    "title": "Removed from the developer site as it is incomplete | IDEA StatiCa API",
    "keywords": "Status: 👷‍♂️ Work In Progress. Have a question relating to the topic? Please add an issue. Removed from the developer site as it is incomplete Origin Settings //To do"
  },
  "docs/iom/iom_open_model_result.html": {
    "href": "docs/iom/iom_open_model_result.html",
    "title": "IOM Open Model Result | IDEA StatiCa API",
    "keywords": "IOM Open Model Result The IOM OpenModelResult class provides a way of storing member force results from an FEA analysis that is related to IOM OpenModel. The relationships between the IOM and the IOM Results are defined by the ID of objects. The OpenModelResult can be serialized to XML and saved as .xml file or .xmlR file (for easier navigation). Background While the 'OpenModel' class provides the definition of the geometry, load cases, loads, load combinations, etc the OpenModelResult class provides a way of transferring FEA result data. The OpenModel and OpenModelResult are considered seperately in order: To allow for the possibility for geometry and force extraction to come from alternative sources Provide the ability for one result file to relate to multiple IOM Open Model Connection files. IOM Result Data Structure The OpenModelResult structure is designed to store a complete representation of the member force result diagrams from an ENTIRE structure. These force diagrams are then interpreted (refer below) by IDEA StatiCa Connection to produce the forces at a connection level. Generally speaking, when importing forces through IOM OpenResultClass they should always be in equilibrium when interpreted by IDEA Connection. The OpenModelResult is structured in the following XML Format: <?xml version=\"1.0\" encoding=\"utf-16\"?> <OpenModelResult xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"> <ResultOnMembers> <ResultOnMembers> <Members> <ResultOnMember> <Member> <MemberType>Member1D</MemberType> <Id>1</Id> </Member> <ResultType>InternalForces</ResultType> <Results> <ResultBase xsi:type=\"ResultOnSection\"> <AbsoluteRelative>Absolute</AbsoluteRelative> <Position>0</Position> <Results> <SectionResultBase xsi:type=\"ResultOfInternalForces\"> <Loading> <LoadingType>LoadCase</LoadingType> <Id>1</Id> <Items> <ResultOfLoadingItem> <Coefficient>1</Coefficient> </ResultOfLoadingItem> </Items> </Loading> <N>242.96484375</N> <Qy>0</Qy> <Qz>1176.9375</Qz> <Mx>0</Mx> <My>-727.5482177734375</My> <Mz>0</Mz> </SectionResultBase> <SectionResultBase xsi:type=\"ResultOfInternalForces\"> <Loading> <LoadingType>LoadCase</LoadingType> <Id>2</Id> <Items> <ResultOfLoadingItem> <Coefficient>1</Coefficient> </ResultOfLoadingItem> </Items> </Loading> <N>20200.224609375</N> <Qy>0</Qy> <Qz>97851.2109375</Qz> <Mx>0</Mx> <My>-60488.7421875</My> <Mz>0</Mz> </SectionResultBase> </Results> </ResultBase> <Results> </ResultOnMember> <Members> <ResultOnMembers> <ResultOnMembers> </OpenModelResult> Below is an example of filling the OpenModelResult object by c# code. This example populates Member results by using the MemberType = Element1D method which is explained further below. public static OpenModelResult CreateOpenModelResult(OpenModel openModel) { OpenModelResult openModelResult = new OpenModelResult(); openModelResult.ResultOnMembers = new List<ResultOnMembers>(); ResultOnMembers resIF = new ResultOnMembers(); //Generate Results for Each Member1D for (int ib = 0; ib < openModel.Member1D.Count; ib++) { Member1D mb = openModel.Member1D[ib]; for (int iel = 0; iel < mb.Elements1D.Count; iel++) { Element1D elem = openModel.Element1D.First(c => c.Id == mb.Elements1D[iel].Id); ResultOnMember resMember = new ResultOnMember(new Member() { Id = elem.Id, MemberType = MemberType.Element1D }, ResultType.InternalForces); int numPoints = 2; for (int ip = 0; ip <= numPoints; ip++) { ResultOnSection resSec = new ResultOnSection(); resSec.AbsoluteRelative = AbsoluteRelative.Relative; resSec.Position = (double)ip / (double)numPoints; int count = openModel.LoadCase.Count; for (int i = 0; i < count; i++) { ResultOfInternalForces resLc = new ResultOfInternalForces(); resLc.Loading = new ResultOfLoading() { Id = openModel.LoadCase[i].Id, LoadingType = LoadingType.LoadCase }; resLc.Loading.Items.Add(new ResultOfLoadingItem() { Coefficient = 1.0 }); resLc.N = 5000; resLc.Qy = 2; resLc.Qz = 3; resLc.Mx = 4; resLc.My = (ip + 1) * 5000; resLc.Mz = 6; resSec.Results.Add(resLc); } resMember.Results.Add(resSec); } resIF.Members.Add(resMember); } } openModelResult.ResultOnMembers.Add(resIF); return openModelResult; } Extracting Member Force Results In order for connection forces to be interpreted correctly a good understanding of the local coordinate system of members and sign force direction conventions is required. This is explained here. It is also important to understand the make-up of Element and Member Geometry, which is explained in detail [here]. In short, Elements will go from FEA Node to Node. Members can be continuous through Nodes and encapsulate 1, 2, or more Elements. Forces by MemberType: Member1D or Element1D All forces relate to Members in IDEA Statica, however, IOM Result Data provides two ways of specifying the Member Result information and IDEA StatiCa provides two ways of interpreting the data in order to translate it to connection member forces. This makes it easier for users to generate result data from different applications. Internally, we use both of them, depending on the API of the 3rd party software. There are two options when defining a member result to a new ResultOnMember: Specifying Result by Element: This relates results to an Element in the IOM Model. ResultOnMember resMember = new ResultOnMember(new Member() { Id = elem.Id, MemberType = MemberType.Element1D }, ResultType.InternalForces); Specifying Result by Member: This relates results to a Member in the IOM Model. ResultOnMember resMember = new ResultOnMember(new Member() { Id = member.Id, MemberType = MemberType.Member1D }, ResultType.InternalForces); Below shows the difference between creating result data from the two different methods: Result Data By MemberType = Element1D Start and Endpoints can be defined directly at the start and endpoints. Therefore, IDEA StatiCa will interpret the end results on either side of the member by the endpoint values of the element. Internal results can be defined as a single relative or absolute value along the element to better represent the member force diagrams. As a minimum Member Results by Element Type MUST provide a SectionResult for the start and endpoint (2 results). Result Data By MemberType = Member1D Start and Endpoints can be defined directly at the start and end nodes (of the member). For internal member results at the location of connection nodes two values should be specified, one either side of the point to an absolute or relative position of 1E-6 away from the location of the node. Refer below for further information on this. Other internal member results can be defined as a single relative or absolute value along the member to better represent the member force diagrams. Interpretation of ResultData It is important to understand how IDEA StatiCa Connection interprets the IOM Result Data to generate the connection members load effects. Note there was a slight change in how the load effects and their values are set to a connection project from continuous members. Since version 21, we are aligning with a whole structure approach (due to the addition of the Checkbot app). This is to ensure data consistency between both workflows (generating a single connection project & importing a whole structure to Checkbot and generating multiple connections based on that). To get to the values needed when creating a connection project from the IOM Result Data we currently: a) Read it directly (if available), or b) Interpolate between the two closest defined values in the IOM Result Data. For a continuous member, in order to read the \"before\" and \"after\" values in a connection point, we look for section results 1e-6 away from the connection point (relatively). This is why it is imperative that two result points (one on either side of the connection point) are defined when using the MemberType = Member1D option. It is almost certain that an interpolated value between the start and end node of a member which contains more than one element will yield unbalanced forces. Local vs Principle Axis system To do Defining forces Not in Equilibrium Currently, it is not easy to define simple forces (forces that are not in equilibrium) and it is not recommended. Although, you can set the connection when imported to not require equilibrium of imported forces. This would mean forces on bearing members would not require to be provided."
  },
  "docs/iom/iom_units.html": {
    "href": "docs/iom/iom_units.html",
    "title": "Units | IDEA StatiCa API",
    "keywords": "Units All units defined in the IOM Model are to be specified as SI. Type Unit Comment Length m All length units including Section Properties Force N Angle Rad Moment Nm Stress Pa (N/m2) Temperature K Kelvin Mass kg Time sec Frequency Hz Some Unit References: Type Unit Comment Thermal Conductivity W/(mK) Spring Stiffness N/m Rotational Spring Nm/rad"
  },
  "examples/api/csharp/connection/Connection-API-Console-Tester/ConHiddenCheckConsole/readme.html": {
    "href": "examples/api/csharp/connection/Connection-API-Console-Tester/ConHiddenCheckConsole/readme.html",
    "title": "| IDEA StatiCa API",
    "keywords": "ConHiddenCheckConsole It is very simple console application example. ConnCalculatorConsole.exe requires the path to IDEA Statica installation directory and optionly the path to the idea connection project. If any project is passed the default project for this example is calculated. The example uses @\"IdeaStatiCa.Plugin\" for running CBFEM analysis. Running this example it requires IDEA StatiCa v 21.0 (or higher) on an user's PC. Free trial version version can be obtained here. Running CBFEM from the commad line : ConnCalculatorConsole.exe \"C:\\Program Files\\IDEA StatiCa\\StatiCa 21.0\" \"c:\\test.ideaCon\""
  },
  "examples/api/csharp/connection/Connection-API-WinForm-Tester/ConnectionAutomationApp/readme.html": {
    "href": "examples/api/csharp/connection/Connection-API-WinForm-Tester/ConnectionAutomationApp/readme.html",
    "title": "| IDEA StatiCa API",
    "keywords": "The example of controlling IdeaConnection.exe from another process - see project ConnectionAutomationApp This examples use @\"IdeaStatiCa.Plugin\" for communication with IdeaConnection.exe. Running this example it requires IDEA StatiCa v 20.0 (or higher) on an user's PC. Free trial version version can be obtained here. Starting IdeaConnection.exe // it starts the new process of IdeaConnection.exe which is located in the directory ideaStatiCaDir this.ConnectionController = IdeaConnectionController.Create(ideaStatiCaDir); When IdeaConnection.exe is running the project can be open // open selected idea connection project in the running application IdeaConnection.exe onnectionController.ConnectionAppAutomation.OpenProject(openFileDialog.FileName); Closing open project // open selected idea connection project in the running application IdeaConnection.exe ConnectionController.ConnectionAppAutomation.OpenProject(openFileDialog.FileName);"
  },
  "examples/api/csharp/connection/Connection-API-WinForm-Tester/ConnectionHiddenCalculation/readme.html": {
    "href": "examples/api/csharp/connection/Connection-API-WinForm-Tester/ConnectionHiddenCalculation/readme.html",
    "title": "| IDEA StatiCa API",
    "keywords": "ConnectionHiddenCalculation It is more complex example which presents more features which are provided by IDEA StaiCa API. To be able to run this example set the path to Idea StatiCa directory in the project settings. Communication of a 3rd party application (the example ConnectionHiddenCalculation in this case) with ConnectionCalcService which runs in a another process. In the project IdeaStatiCa.ConnectionClient there are commands which control @\"IdeaStatiCa.Plugin.IConnHiddenCheck\" Service. These commands show how to : Open IDEA Connection project Import IDEA Connection from IOM Close IDEA Connection project Calculate a connection Get geometry of a connection Create template from a connection Apply template Delete all operations from the connection There are new methods for getting information about materials, cross-sections and bolt assemblies in idea connection project in IConnHiddenCheck since version IDEA StatiCa v20.0.81. It is also possible to add new bolt assemblies into a connection project - see method : /// <summary> /// Add the new bolt assembly. Its type is defined by its name (e.g. 'M12 4.6') /// </summary> /// <param name=\"boltAssemblyName\"></param> /// <returns></returns> [OperationContract] int AddBoltAssembly(string boltAssemblyName); The method ApplyTemplate has the new parameter connTemplateSetting. It defines materials which are used when template is applied. The examples of using these new IConnHiddenCheck methods can be found in examples : GetMaterialsInProject GetCrossSectionsInProject GetBoltAssembliesInProject AddBoltAssembly Improvements in version IDEA StatiCa v 20.1 API users can apply simple template to a connection. There is the example how to call the service in the command : Apply Simple template /// <summary> /// Apply the simple connectionsimple template from file <paramref name=\"templateFilePath\"/> on connection <paramref name=\"connectionId\"/> /// </summary> /// <param name=\"connectionId\">The id of the connection on which templete will be applied</param> /// <param name=\"templateFilePath\">The path to the connection template</param> /// <param name=\"connTemplateSetting\">The additional settings - e.g. default bolts</param> /// <param name=\"mainMember\">Main (supporting member)</param> /// <param name=\"attachedMembers\">The list of members which are supported by <paramref name=\"mainMember\"/></param> /// <returns>Returns 'Ok' in case of the success otherwise 'Fail'</returns> [OperationContract] string ApplySimpleTemplate(string connectionId, string templateFilePath, ApplyConnTemplateSetting connTemplateSetting, int mainMember, List<int> attachedMembers); How to test applying single template step by step Build project ConnectionHiddenCalculation Open the empty connection project 2-beams-to-column-empty.ideaCon in app ConnectionHiddenCalculation Specify supporting member (in this cas 1) and supported member (in this case 2) Click on the button Apply simple template Save project as and open it in ideaconnection.exe to check the result You can apply template twice - for member 2 anb 3 to get the complete connection There is the online API Documentation of manufacturing operations. It helps to set values of properties of operations. The best way is to create a connection model in ideaconnection.exe - save is as connection template - you can find this feature in this example. Then open it in a text editor and check the content. Then you can modify values in contemp file and apply it again. Improvements in version IDEA StatiCa v 21.0 We added the method GetAllConnectionData to our API interface IConnHiddenCheck. This method returns the instance of IdeaRS.OpenModel.OpenModelTuple for a selected connection. This instance includes structural data and corresponding results of FE analysis."
  },
  "examples/api/python/connection/parameter-example/readme.html": {
    "href": "examples/api/python/connection/parameter-example/readme.html",
    "title": "parameters-anchors | IDEA StatiCa API",
    "keywords": "parameters-anchors This example shows how to modify parameters of the IDEA Connection from Python. In this example, the bending moment, the thickness of the base plate and the length of the anchors are modified. Results are printed to the console. How to set parameters in idea connection project is described on ths page To able to run the script from the command line you need to navigate to the directory which includes the python script an run : python parameters-anchors.py Prerequisites Install Python v37 Install Python.NET as it is described on here Install Idea StatiCa v21 or higher Build the release configuration of the solution ConnCalcExamples\\ConnCalculationExamples.sln. The python script needs .net assemblies in in the directory '..\\ConnCalcExamples\\ConnectionHiddenCalculation\\bin\\Release'"
  },
  "examples/bimapi/CheckbotBimLink/readme.html": {
    "href": "examples/bimapi/CheckbotBimLink/readme.html",
    "title": "Checkbot BIM Link Example for an FEA Application. | IDEA StatiCa API",
    "keywords": "Checkbot BIM Link Example for an FEA Application. Intro Here we provied two simple examples on how to create a link with IDEA StatiCa Checkbot and either a FEA or CAD Application using our BimApiLink Framework. There are typically some requirements to ensure a connection can be completed successfully with Checkbot. In these examples we provide Fake/Mock/Simulation API's for both the CAD and FEA applications, which should be replaced by your application API. You can read more about this here. Before creating your own link we always encourage you to get in-touch with us to discuss co-operation. Example Example requirements Visual Studio 2022 or Greater Architecture The Below relates to the FEA example, however the CAD example follows the exact same logic. There are two main projects in each example: BimApiLinkFEAExample - The primary Class Library project which provides linking and conversion with the Checkbot application. Look First Look at TestPlugin.cs to get started. The Run() method is the primary method which will be called from your application. Dependency Injection Our BimLinkFramework relys on automatic dependency injection. We use Autofac for this. Within the BuildContainer() method we define the instances used in the plugin. FeaExampleApi* - A class library project which provides some dumby structural geometry and other inputs to the BimApiLinkFEAExample. It emulates a typical API of an FEA software and provides some dumby structural information. *When creating your own link only the BimApiLinkExample would be required. The BimApiExample should be replaced by a command interface or other small app which allows your program to host and run the link. FeaExampleApi should be replaced with the third party API object. BimLinkExampleRunner* - Simple windows form app for running and testing the BimApiLinkFEAExample or BimApiLineCadExample. Implements the Run() command provided from the TestPlugin. *This is only used for demonstrating in the test enviroment. This will be replaced by on the third-party developers side with either another simple app runner or a command interface. Look First Navigate to the folder ViewModels > MainWindowViewModel.cs. The MainWindowViewModel class provides a method called OnRunCheckbot() which implements the TestPlugin.Run() method. The FEAExampleApi is provide to the TestPlugin. Building the example Clone the idea-statica/public repository. Some typical instructions here. In windows explorer navigate to the repository location /src folder and open the solution IdeaStatiCa.Public.sln in visual studio. Build the entire solution, which may take a minute or two. There should be no errors. Navigate to the example location and right click on the BimLinkExampleRunner and select set as start-up project. Running the example This simple example will run Checkbot and allow you to import some simple Member and Node objects which we have defined in the FakeFEAApi. Run the BimLinkExampleRunner project. A form should appear. We need to provide the link to the Checkbot executable. This allows you to select which version of IDEA StatiCa you would like to run. For example: C:\\Program Files\\IDEA StatiCa\\StatiCa 23.1\\IdeaCheckbot.exe Now we can Run IDEA StatiCa Checkbot. This triggers the TestPlug.Run() command. [info] A new Checkbot project folder will automatically be created (if one has not already been created) in the the /bin folder. The new project screen will appear. You will be prompted to select a Country Code (Select EU for this example) and Create the Checkbot project. Checkbot should now open to a black screen. On creating the Checkbot project, a project file IdeaStatiCa.proj is saved into the checkbot folder. Next time checkbot is run it will detect this file and the project will be opened automatically wher you left off. To reset the test, simply delete the created Checkbot folder. In the top left hand corner of the ribbon, click 'Connections'. This triggers the GetUserSelection() method in the 'Model' class of Model.cs. Here we provide the indentifiers of the objects that we want to import. One column (M7) and one beam (M13) should be imported, with three connections (C 9, C 15, C 16). END OF EXAMPLE Copying the example to create a new Link To start work on a link of your own, you can copy the BimApiLinkFeaExample or BimApiLinkCadExample project and rename it. You will need to bulk rename the namespace in the example. A typical naming structure is [AppName]Link. You can use the BimApiExample to test your duplicated plugin by changing the project reference from the BimApiLinkFEAExample to your created project. When creating your own link only the BimApiLinkExample would be required, BimLinkExampleRunner should be replaced by a command interface or other small app which allows your program to host and run the link. FeaExampleApi should be replaced with the third party API Model object. References As you will eventually deploy your plugin outside of the test environment, it is best to reference required modules via Nuget and remove current project dependencies. Simply double click on your project in the solution explorer and modify the xml as below. We also highly reccommend that you update to the latest NuGet packages at this point. <ItemGroup> <PackageReference Include=\"Autofac\" Version=\"6.4.0\" /> <PackageReference Include=\"Autofac.Extensions.DependencyInjection\" Version=\"8.0.0\" /> <PackageReference Include=\"IdeaStatiCa.BimApiLink\" Version=\"22.1.0.3519\" /> <PackageReference Include=\"IdeaStatiCa.BimImporter\" Version=\"22.1.0.3519\" /> <PackageReference Include=\"IdeaStatiCa.Plugin\" Version=\"22.1.0.3519\" /> </ItemGroup> You should also remove the current reference to the FeaExampleApi and inject your own applications Api DLLs. Further Information In a fully functioning link, there are typically a number of different importers and further conversion utilities which are outside the scope of this example. We will continue to improve on this example where required. Please comment in the discussion forums if you require further clarification or information."
  },
  "examples/iom/IOM/IOM.SteelFrameDesktop/readme.html": {
    "href": "examples/iom/IOM/IOM.SteelFrameDesktop/readme.html",
    "title": "| IDEA StatiCa API",
    "keywords": "The example of creating IDEA Connection project IOM locally is in the project The example how to generate IOM for a steel frame and including geometry of connections is in IOM.GeneratorExample. Running this example requires IDEA StatiCa v 20.0 (or higher) on an user's PC. Free trial version version can be obtained here. @\"IdeaStatiCa.Plugin\" includes classes which allows communication and controlling IDEA StatiCa applications and its provides services to other applications. IdeaStatiCa.Plugin is also distributed as nuget package // create IOM and results OpenModel example = SteelFrameExample.CreateIOM(); OpenModelResult result = Helpers.GetResults(); string iomFileName = \"example.xml\"; string iomResFileName = \"example.xmlR\"; // save to the files example.SaveToXmlFile(iomFileName); result.SaveToXmlFile(iomResFileName); The instance of the class @\"IdeaStatiCa.Plugin.ConnHiddenClientFactory\" is responsible for creating the instance of ConnectionHiddenCheckClient which communicates with the local installation of Idea StatiCa. The path to the installation directory is passed in the constructor of ConnHiddenClientFactory IdeaInstallDir = IOM.SteelFrameDesktop.Properties.Settings.Default.IdeaInstallDir; Console.WriteLine(\"IDEA StatiCa installation directory is '{0}'\", IdeaInstallDir); ConnectionHiddenCheckClient calcFactory = new ConnHiddenClientFactory(IdeaInstallDir); The installation directory of Idea StatiCa v 21.0 (or higher) is set in the project setting of IOM.SteelFrameDesktop. Idea Connection project is created by calling method CreateConProjFromIOM client.CreateConProjFromIOM(iomFileName, iomResFileName, fileConnFileNameFromLocal); Console.WriteLine(\"Generated project was saved to the file '{0}'\", fileConnFileNameFromLocal);"
  },
  "examples/iom/IOM/IOM.SteelFrameWeb/readme.html": {
    "href": "examples/iom/IOM/IOM.SteelFrameWeb/readme.html",
    "title": "| IDEA StatiCa API",
    "keywords": "The example of creating IDEA Connection project by webservice It allows to generate idea connection project without having Idea StatiCa on your PC. IOM and IOM results are sent to webservice which generates and returns Idea Connection project. public static readonly string viewerURL = \"https://viewer.ideastatica.com\"; public static void CreateOnServer(OpenModel model, OpenModelResult openModelResult, string path) { IdeaRS.OpenModel.OpenModelContainer openModelContainer = new OpenModelContainer() { OpenModel = model, OpenModelResult = openModelResult, }; // serialize IOM to XML var stringwriter = new System.IO.StringWriter(); var serializer = new XmlSerializer(typeof(OpenModelContainer)); serializer.Serialize(stringwriter, openModelContainer); var serviceUrl = viewerURL + \"/ConnectionViewer/CreateFromIOM\"; Console.WriteLine(\"Posting iom in xml to the service {0}\", serviceUrl); var resultMessage = Helpers.PostXMLData(serviceUrl, stringwriter.ToString()); ResponseMessage responseMessage = JsonConvert.DeserializeObject<ResponseMessage>(resultMessage); Console.WriteLine(\"Service response is : '{0}'\", responseMessage.status); if (responseMessage.status == \"OK\") { byte[] dataBuffer = Convert.FromBase64String(responseMessage.fileContent); Console.WriteLine(\"Writing {0} bytes to file '{1}'\", dataBuffer.Length, path); if (dataBuffer.Length > 0) { using (FileStream fileStream = new FileStream(path , FileMode.Create , FileAccess.Write)) { fileStream.Write(dataBuffer, 0, dataBuffer.Length); } } else { Console.WriteLine(\"The service returned no data\"); } } } }"
  },
  "examples/iom/IOM/readme.html": {
    "href": "examples/iom/IOM/readme.html",
    "title": "IOM Example - SteelFrame | IDEA StatiCa API",
    "keywords": "IOM Example - SteelFrame This example describes how to define a steel frame in IOM (IDEA StatiCa Open Model). The source code of this example is in the project IOM.GeneratorExample The generated IOM can be used for creating IDEA StatiCa Connection project (ideacon). It can be done on a desktop PC where IDEA StatiCa is installed. More details how to do are in the project IOM.SteelFrameDesktop. It requires the installation of IdeaStatiCa on PC. Idea Connection project can be also generated from IOM by the webservice which runs in IDEA Cloud. More details are in the project IOM.SteelFrameWeb Creating IOM for steel frame step by step Let's create a standard console application in MS Visual Studio. Select File > New > Project from the menu bar. In the dialog, select the Visual C# node followed by the Get Started node. Then select the Console App project template. Add the IdeaRS.OpenModel NuGet package OpenModel is published as the nuget package. To install this package, you can use either the Package Manager UI or the Package Manager Console. For more information, see Install and use a package in Visual Studio There is also full documentation related to IdeaRS.OpenModel. The geometry of the steel frame The geometrical model of the steel structure which you can see in the picture below will be created in this step. The model consists of several columns and beams. The project settings A basic information about our project - such as a project name, a description etc. // create new instance of the open model model.OriginSettings = new OriginSettings(); model.OriginSettings.CrossSectionConversionTable = CrossSectionConversionTable.SCIA; model.OriginSettings.CountryCode = CountryCode.ECEN; model.OriginSettings.ProjectName = \"Project\"; model.OriginSettings.Author = \"IDEA StatiCa s.r.o.\"; model.OriginSettings.ProjectDescription = \"Training example\"; More datails can be found here OriginSettings. Definition of materials in our model *The type of materials corresponds to the selected design code for our project ! We can't mixed Reference to the materials in open model is IdeaRS.OpenModel.Material MatSteelEc2 material = new MatSteelEc2(); // set properties material.Id = 1; material.Name = \"S355\"; material.E = 210000000000; material.G = material.E / (2 * (1 + 0.3)); material.Poisson = 0.3; material.UnitMass = 7850; material.SpecificHeat = 0.6; material.ThermalExpansion = 0.000012; material.ThermalConductivity = 45; material.IsDefaultMaterial = false; material.OrderInCode = 0; material.StateOfThermalExpansion = ThermalExpansionState.Code; material.StateOfThermalConductivity = ThermalConductivityState.Code; material.StateOfThermalSpecificHeat = ThermalSpecificHeatState.Code; material.StateOfThermalStressStrain = ThermalStressStrainState.Code; material.StateOfThermalStrain = ThermalStrainState.Code; material.fy = 355000000; material.fu = 510000000; material.fy40 = 335000000; material.fu40 = 470000000; material.DiagramType = SteelDiagramType.Bilinear; // add material to the model model.AddObject(material); Definition of cross sections in our model Reference to the cross sections in open model is IdeaRS.OpenModel.CrossSection. Model has two types of cross sections: HE200B and HE240B. To create a single cross-section you need to know the material from previous section. // only one material is in the model MatSteel material = model.MatSteel.FirstOrDefault(); CrossSectionParameter css = new CrossSectionParameter(); css.Id = 1; css.Name = \"HE200B\"; css.CrossSectionRotation = 0; css.CrossSectionType = CrossSectionType.RolledI; css.Parameters.Add(new ParameterString() { Name = \"UniqueName\", Value = \"HE200B\" }); css.Material = new ReferenceElement(material); // add cross sections to the model model.AddObject(css); Nodes in the geometrical model Individual nodes are placed in the structure as follows: Table of all nodes with given coordinates: Node X Y Z N1 -2 3 0 N2 -2 3 3 N3 2 3 0 N4 2 3 3 N5 6 3 0 N6 6 3 3 N7 -2 3 6 N8 2 3 6 N9 6 3 6 Create 3D point and fill properties: id, name and coordinates. // create N1 Point3D N1 = new Point3D() { X = -2, Y = 3, Z = 0 }; N1.Name = \"N1\"; N1.Id = 1; model.AddObject(N1); // create N2 Point3D N2 = new Point3D() { X = -2, Y = 3, Z = 3 }; N2.Name = \"N2\"; N2.Id = 2; model.AddObject(N2); // and so on... 1D members in our model Each instace of Member1D has one ore more instances Element1D. 1. The example of an instance of Member1D which has only one Element1D and it is connected as an ended member into a connection. The code below describes how to create a member which has only one Element1D Please notice, for better readability there are also helper functions like CreateLineSegment3D, CreateElement1D and CreateMember1D that you can find here. // set the appropriate cross section var css_he_200b = model.CrossSection.FirstOrDefault(item => item.Name == \"HE200B\"); // define the geometry of the member - the line segment connecting nodes N2 and N4 LineSegment3D segment = CreateLineSegment3D(model, \"N2\", \"N4\"); // create the polyline (polylines can consist of one ore more segments) PolyLine3D polyline = new PolyLine3D(); polyline.Id = model.GetMaxId(polyline) + 1; polyline.Segments.Add(new ReferenceElement(segment)); // add polylines and segments to the model model.AddObject(polyline); model.AddObject(segment); // create one 1D element Element1D element = CreateElement1D(model, css, segment); model.AddObject(element); // create one 1D member which has one element1D Member1D member = CreateMember1D(model, 1, Member1DType.Beam, element); model.Member1D.Add(member); // create the instance of a ConnectedMember - it defines the geometrical bahaviour of our Member1D in a connection. It can be ended or continouous. // Member1D can be part of more connections ConnectedMember M1 = new ConnectedMember(); M1.Id = 1; M1.MemberId = new ReferenceElement(member); model.AddObject(M1); 2. The example of an instance of Member1D which has two Element1Ds - it can be connected as an continuous member into a connection (by its middle node). The code below describes the creation of second member - which connects 3 nodes the begin node (N1), the middle node (N2) and the end node (N7). // set its cross sections var css_he_240b = model.CrossSection.FirstOrDefault(item => item.Name == \"HE240B\"); // define geometry // create line segment from N1 to N2 LineSegment3D segment1 = CreateLineSegment3D(model, \"N1\", \"N2\"); model.AddObject(segment1); // create line segment from N2 to N7 LineSegment3D segment2 = CreateLineSegment3D(model, \"N2\", \"N7\"); model.AddObject(segment2); // create the polyline PolyLine3D polyline = new PolyLine3D(); polyline.Id = model.GetMaxId(polyline) + 1; polyline.Segments.Add(new ReferenceElement(segment1)); polyline.Segments.Add(new ReferenceElement(segment2)); model.AddObject(polyline); // create 1D elements Element1D element1 = CreateElement1D(model, css, segment1); model.AddObject(element1); Element1D element2 = CreateElement1D(model, css, segment2); model.AddObject(element2); // create 1D members Member1D member = CreateMember1D(model, 2, Member1DType.Column, element1, element2); model.Member1D.Add(member); // create and return connected member ConnectedMember M2 = new ConnectedMember(); M2.Id = id; M2.MemberId = new ReferenceElement(member); model.AddObject(M2); The local coordinate system of members It its important to pay attantion to the correct setting of coordinate systems of members. It must correspond to coordinate systems which are used in your FEA model otherwise it can caused unbalanced internal forces in exported connections. There are 3 options how to define the coordinate system for member 1d : CoordSystemByPoint CoordSystemByVector CoordSystemByZup The coordinate system is a property of @\"IdeaRS.OpenModel.Geometry3D.Segement3D\" LineSegment3D segment3D = new LineSegment3D(); segment3D.StartPoint = new ReferenceElement(model.Point3D.FirstOrDefault(item => item.Name == startNode)); CoordSystemByPoint system = new CoordSystemByPoint(); system.Point = new Point3D() { X = 100000, Y = 0, Z = 0 }; system.InPlane = Plane.ZX; segment3D.LocalCoordinateSystem = system; The loading of the steel frame Load cases // create the load group for pernament loadcases LoadGroupEC LG1 = new LoadGroupEC(); ; LG1.Id = 1; LG1.Name = \"PERM1\"; LG1.Relation = Relation.Standard; LG1.GroupType = LoadGroupType.Permanent; LG1.GammaQ = 1.35; LG1.Dzeta = 0.85; LG1.GammaGInf = 1; LG1.GammaGSup = 1.35; model.AddObject(LG1); // create the second load group for variable loadcases LoadGroupEC LG2 = new LoadGroupEC(); ; LG2.Id = 2; LG2.Name = \"VAR1\"; LG2.Relation = Relation.Exclusive; LG2.GroupType = LoadGroupType.Variable; LG2.GammaQ = 1.5; LG2.Dzeta = 0.85; LG2.GammaGInf = 0; LG2.GammaGSup = 1.5; LG2.Psi0 = 0.7; LG2.Psi1 = 0.5; LG2.Psi2 = 0.3; model.AddObject(LG2); // create the first load case representing SelfWeight LoadCase LC1 = new LoadCase(); LC1.Id = 1; LC1.Name = \"SelfWeight\"; LC1.LoadType = LoadCaseType.Permanent; LC1.Type = LoadCaseSubType.PermanentStandard; LC1.Variable = VariableType.Standard; LC1.LoadGroup = new ReferenceElement(LG1); // create the second load case representing PernamentLoading LoadCase LC2 = new LoadCase(); LC2.Id = 2; LC2.Name = \"PernamentLoading\"; LC2.LoadType = LoadCaseType.Permanent; LC2.Type = LoadCaseSubType.PermanentStandard; LC2.Variable = VariableType.Standard; LC2.LoadGroup = new ReferenceElement(LG1); // create the third load case representing LiveLoad LoadCase LC3 = new LoadCase(); LC3.Id = 3; LC3.Name = \"LiveLoad\"; LC3.LoadType = LoadCaseType.Variable; LC3.Type = LoadCaseSubType.VariableStatic; LC3.Variable = VariableType.Standard; LC3.LoadGroup = new ReferenceElement(LG2); // add load cases to the model model.AddObject(LC1); model.AddObject(LC2); model.AddObject(LC3); Define Load Combinations // create first combination input CombiInputEC CI1 = new CombiInputEC(); CI1.Id = model.GetMaxId(CI1) + 1; CI1.Name = \"Co.#1\"; CI1.Description = \"SelfWeight + PernamentLoading + LiveLoad\"; CI1.TypeCombiEC = TypeOfCombiEC.ULS; CI1.TypeCalculationCombi = TypeCalculationCombiEC.Linear; CombiItem item = new CombiItem(); item.Id = 1; item.Coeff = 1; item.LoadCase = new ReferenceElement(model.LoadCase.FirstOrDefault(l => l.Name == \"SelfWeight\")); CI1.Items.Add(item); item = new CombiItem(); item.Id = 2; item.Coeff = 1; item.LoadCase = new ReferenceElement(model.LoadCase.FirstOrDefault(l => l.Name == \"PernamentLoading\")); CI1.Items.Add(item); item = new CombiItem(); item.Id = 3; item.Coeff = 1; item.LoadCase = new ReferenceElement(model.LoadCase.FirstOrDefault(l => l.Name == \"LiveLoad\")); CI1.Items.Add(item); model.AddObject(CI1); // and so on... Connections A connection is defined by its reference node and connected members. A member can be ended or continuous. From the design point of view the balance of loading in the node is required. Axis X of the local coordinate system of an ended member points out of a connection. // create first connection point ConnectionPoint CP1 = new ConnectionPoint(); CP1.Node = new ReferenceElement(model.Point3D.FirstOrDefault(n => n.Name == \"N2\")); CP1.Id = model.GetMaxId(CP1) + 1; CP1.Name = \"CON \" + CP1.Id.ToString(); // members from previous section CP1.ConnectedMembers.Add(M1); CP1.ConnectedMembers.Add(M3); model.AddObject(CP1); Loading impulses acting on mebers in a connection model Loading impuses for our connection are determined from results of FE analysis. IDEA OpenModel allowes to pass internal forces on members by OpenResuls class. Internal forces on members Results of internal forces which were generated by a FEA application can be optionally saved as in the format of OpenModelResult. It contains internal forces on the Member1Ds. The relationships between the IOM and the IOM Results are defined by ID of objects. The file (.xmlR) with results can be found here. Format is as follows: <?xml version=\"1.0\" encoding=\"utf-16\"?> <OpenModelResult xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"> <ResultOnMembers> <ResultOnMembers> <Members> <ResultOnMember> <Member> <MemberType>Member1D</MemberType> <Id>1</Id> </Member> <ResultType>InternalForces</ResultType> <Results> <ResultBase xsi:type=\"ResultOnSection\"> <AbsoluteRelative>Absolute</AbsoluteRelative> <Position>0</Position> <Results> <SectionResultBase xsi:type=\"ResultOfInternalForces\"> <Loading> <LoadingType>LoadCase</LoadingType> <Id>1</Id> <Items> <ResultOfLoadingItem> <Coefficient>1</Coefficient> </ResultOfLoadingItem> </Items> </Loading> <N>242.96484375</N> <Qy>0</Qy> <Qz>1176.9375</Qz> <Mx>0</Mx> <My>-727.5482177734375</My> <Mz>0</Mz> </SectionResultBase> <SectionResultBase xsi:type=\"ResultOfInternalForces\"> <Loading> <LoadingType>LoadCase</LoadingType> <Id>2</Id> <Items> <ResultOfLoadingItem> <Coefficient>1</Coefficient> </ResultOfLoadingItem> </Items> </Loading> <N>20200.224609375</N> <Qy>0</Qy> <Qz>97851.2109375</Qz> <Mx>0</Mx> <My>-60488.7421875</My> <Mz>0</Mz> </SectionResultBase> </Results> </ResultBase> <Results> </ResultOnMember> <Members> <ResultOnMembers> <ResultOnMembers> </OpenModelResult> Validation of the exported connection If everything is set correctly loads are in equilibrium. You can download idea project file of our steel frame which can be open in IDEA StatiCa Designer. You can also download idea connection file of the created connection which can be open in IDEA StatiCa Connection. Definition of a geometry of a connection The geometry of a connection can be defined for each connection point in IOM. Following data about connected members, their cutting (shortening) and components of the connection (plates, welds, bolts) are required for creating a connection. Additional connection data in the connection point: IdeaRS.OpenModel.Connection.ConnectionPoint connection = new IdeaRS.OpenModel.Connection.ConnectionPoint(); IdeaRS.OpenModel.Geometry3D.Point3D point = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2, Y = 3, Z = 3 }; point.Id = openModel.GetMaxId(point) + 1; point.Name = point.Id.ToString(); openModel.Point3D.Add(point); //add connection to IOM connection.Node = new ReferenceElement(point); connection.Name = point.Name; connection.Id = openModel.GetMaxId(connection) + 1; openModel.Connections.Add(new IdeaRS.OpenModel.Connection.ConnectionData()); openModel.AddObject(connection); Connected members There can be one or more connected mebers in a connection. The information about behaviour and properties of a connected member are passed by the instances of the class BeamData. Id - unique identificator [int] OriginalModelId - unique identificator from original model [string] IsAdded - beam is as stiffening member [bool] MirrorY - mirror the cross-section acccording to its XY plane [bool] RefLineInCenterOfGravity - the reference line of a cross-section is in center of gravity [bool] The instance of ConnectedMember has the reference of its 1D model and defines how the member is connected. Id - unique identificator [int] MemberId - reference to member1D represented beam ReferenceElement IsContinuous - a beam can be ended or continuous in a connection[bool] The Example how to create a beam: // openModel.Connections[0].Beams = new List<IdeaRS.OpenModel.Connection.BeamData>(); //Add member1D 1 IdeaRS.OpenModel.Connection.BeamData beam1Data = new IdeaRS.OpenModel.Connection.BeamData { Id = 1, OriginalModelId = \"1\", IsAdded = false, MirrorY = false, RefLineInCenterOfGravity = false, }; openModel.Connections[0].Beams.Add(beam1Data); var member1 = openModel.Member1D.Find(x => x.Id == 1); IdeaRS.OpenModel.Connection.ConnectedMember conMb = new IdeaRS.OpenModel.Connection.ConnectedMember { Id = member1.Id, MemberId = new ReferenceElement(member1), IsContinuous = false, }; connection.ConnectedMembers.Add(conMb); //Add member1D 3 var member3 = openModel.Member1D.Find(x => x.Id == 3); IdeaRS.OpenModel.Connection.ConnectedMember conMb3 = new IdeaRS.OpenModel.Connection.ConnectedMember { Id = member3.Id, MemberId = new ReferenceElement(member3), IsContinuous = true, }; connection.ConnectedMembers.Add(conMb3); IdeaRS.OpenModel.Connection.BeamData beam2Data = new IdeaRS.OpenModel.Connection.BeamData { Id = 3, OriginalModelId = \"3\", IsAdded = false, MirrorY = false, RefLineInCenterOfGravity = false, }; openModel.Connections[0].Beams.Add(beam2Data); ![alt text][Beam] PlateData PlateData includes data about geometry and material of the plate. Name- name of plate [string] Id - unique identificator [int] OriginalModelId - unique identificator from original model [string] Material - name of already defined material in IOM [string] Thickness - thickness of plate defined in metric system(m) [double] Origin - point of local coordinate system defined in global coordinate system Point3D AxisX AxisY AxisZ - axixs of local coordinate system Vector3D Region - geometry of plate descript by SVG path [string] The example how to create a plate: //add plate IdeaRS.OpenModel.Connection.PlateData plateData = new IdeaRS.OpenModel.Connection.PlateData { Name = \"P1\", Thickness = 0.02, Id = 11, Material = \"S355\", OriginalModelId = \"11\", Origin = new IdeaRS.OpenModel.Geometry3D.Point3D { X = -1.87, Y = 2.88, Z = 2.7 }, AxisX = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 0, Y = 1, Z = 0 }, AxisY = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 0, Y = 0, Z = 1 }, AxisZ = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 1, Y = 0, Z = 0 }, Region = \"M 0 0 L 0.24 0 L 0.24 0.5 L 0 0.5 L 0 0\", }; (openModel.Connections[0].Plates ?? (openModel.Connections[0].Plates = new List<IdeaRS.OpenModel.Connection.PlateData>())).Add(plateData); Cutting of connected members Connected mebers can be cut by a plate, other member or a work plane Cut member by other member or plate By IdeaRS.OpenModel.Connection.CutBeamByBeamData you can define cutting beam by other beam or plate. This object requires this values: CuttingObject- reference of a member or plate which is cutting ReferenceElement ModifiedObject- reference of the modified member ReferenceElement IsWeld- flags for welding cut [bool] The example of cutting a beam by a plate: // add cut openModel.Connections[0].CutBeamByBeams = new List<IdeaRS.OpenModel.Connection.CutBeamByBeamData> { new IdeaRS.OpenModel.Connection.CutBeamByBeamData { CuttingObject = new ReferenceElement(plateData), ModifiedObject = new ReferenceElement(beam1Data), IsWeld = true, } }; Cutting a member by a workplane Members can be also cut by a workplane. This cut is defined by properties of an instance of the class By CutData This object requires this values: PlanePoint- point on workplane in global coordinate system Point3D NormalVector- normal vector of workplane Vector3D The example of cutting of a member by a workplane: CutData cutData = new CutData(){ new IdeaRS.OpenModel.Geometry3D.Point3D() { X = 0, Y = 0, Z = 0 }, new IdeaRS.OpenModel.Geometry3D.Vector3D() { X = 1, Y = 0, Z = 0 }, } (beam1Data.Cuts ?? (beam1Data.Cuts = new List<CutData>())).Add(cutData); Bolt grids BoltGrid includes properties of the bolt grid. Id - unique identificator [int] Diameter - diameter of bolt(m) [double] DiagonalHeadDiameter - head diameter of bolt(m) [double] HeadHeight - height head of bolt(m) [double] BoreHole - hole for bolt(m) [double] TensileStressArea - tensile stress area(mm2) [double] NutThickness - nut thickness(m) [double] AnchorLen - lenght of bolt/anchor(m) [double] Material - name of already defined material in IOM [string] Standard - standard of bolt [string] Origin - point of local coordinate system defined in global coordinate system AxisX AxisY AxisZ - axis of local coordinate system Vector3D Positions - list of bolt positions define by points in global coordinate system List<Point3D> ConnectedPartIds - list of identificators object which want to connect together [string] The example of creating of a boltgrid: IdeaRS.OpenModel.Connection.BoltGrid boltGrid = new IdeaRS.OpenModel.Connection.BoltGrid() { Id = 41, ConnectedPartIds = new List<string>(), Diameter = 0.016, HeadDiameter = 0.024, DiagonalHeadDiameter = 0.026, HeadHeight = 0.01, BoreHole = 0.018, TensileStressArea = 157, NutThickness = 0.013, AnchorLen = 0.05, Material = \"8.8\", Standard = \"M 16\", }; boltGrid.Origin = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = plateData.Origin.X, Y = plateData.Origin.Y, Z = plateData.Origin.Z }; boltGrid.AxisX = new IdeaRS.OpenModel.Geometry3D.Vector3D() { X = plateData.AxisX.X, Y = plateData.AxisX.Y, Z = plateData.AxisX.Z }; boltGrid.AxisY = new IdeaRS.OpenModel.Geometry3D.Vector3D() { X = plateData.AxisY.X, Y = plateData.AxisY.Y, Z = plateData.AxisY.Z }; boltGrid.AxisZ = new IdeaRS.OpenModel.Geometry3D.Vector3D() { X = plateData.AxisZ.X, Y = plateData.AxisZ.Y, Z = plateData.AxisZ.Z }; boltGrid.Positions = new List<IdeaRS.OpenModel.Geometry3D.Point3D> { new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -1.87, Y = 2.92, Z = 2.8 }, new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -1.87, Y = 3.08, Z = 2.8 }, new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -1.87, Y = 2.92, Z = 3.15 }, new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -1.87, Y = 3.08, Z = 3.15 } }; boltGrid.ConnectedPartIds = new List<string>() { beam2Data.OriginalModelId, plateData.OriginalModelId }; (openModel.Connections[0].BoltGrids ?? (openModel.Connections[0].BoltGrids = new List<IdeaRS.OpenModel.Connection.BoltGrid>())).Add(boltGrid); Welds Weld By WeldData you can define weld. Id - unique identificator [int] ConnectedPartIds - list of identificators object which want to welded together [string] Start - point of start weld defined in global coordinate system Point3D End - point of end weld defined in global coordinate system Point3D Thickness - thickness of weld defined in metric system(m) [double] WeldType - type of weld WeldType The example of creating stiffeners with welds: IdeaRS.OpenModel.Connection.PlateData plateData2 = new IdeaRS.OpenModel.Connection.PlateData { Name = \"P2\", Thickness = 0.02, Id = 12, Material = \"S355\", OriginalModelId = \"12\", Origin = new IdeaRS.OpenModel.Geometry3D.Point3D { X = -2.103, Y = 2.88, Z = 2.75 }, AxisX = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 1, Y = 0, Z = 0 }, AxisY = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 0, Y = 1, Z = 0 }, AxisZ = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 0, Y = 0, Z = 1 }, Region = \"M 0 0 L 0.206 0 L 0.206 0.105 L 0.195 0.115 L 0.011 0.115 L 0.0 0.105 L 0 0\", }; (openModel.Connections[0].Plates ?? (openModel.Connections[0].Plates = new List<IdeaRS.OpenModel.Connection.PlateData>())).Add(plateData2); //add weld between memeber 2 and plate 2 - stiffener IdeaRS.OpenModel.Connection.WeldData weldData = new IdeaRS.OpenModel.Connection.WeldData() { Id = 31, ConnectedPartIds = new List<string>() { plateData2.OriginalModelId, beam2Data.OriginalModelId }, Start = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2, Y = 2.995, Z = 2.76 }, End = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2, Y = 2.995, Z = 2.76 }, Thickness = 0.004, WeldType = IdeaRS.OpenModel.Connection.WeldType.DoubleFillet, }; (openModel.Connections[0].Welds ?? (openModel.Connections[0].Welds = new List<IdeaRS.OpenModel.Connection.WeldData>())).Add(weldData); //add weld3 between memeber 2 and plate 2 - stiffener IdeaRS.OpenModel.Connection.WeldData weldData3 = new IdeaRS.OpenModel.Connection.WeldData() { Id = 33, ConnectedPartIds = new List<string>() { plateData2.OriginalModelId, beam2Data.OriginalModelId }, Start = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2.103, Y = 2.90, Z = 2.76 }, End = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2.103, Y = 2.90, Z = 2.76 }, Thickness = 0.004, WeldType = IdeaRS.OpenModel.Connection.WeldType.DoubleFillet, }; openModel.Connections[0].Welds.Add(weldData3); //add weld4 between memeber 2 and plate 2 - stiffener IdeaRS.OpenModel.Connection.WeldData weldData4 = new IdeaRS.OpenModel.Connection.WeldData() { Id = 34, ConnectedPartIds = new List<string>() { plateData2.OriginalModelId, beam2Data.OriginalModelId }, Start = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -1.897, Y = 2.90, Z = 2.76 }, End = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -1.897, Y = 2.90, Z = 2.76 }, Thickness = 0.004, WeldType = IdeaRS.OpenModel.Connection.WeldType.DoubleFillet, }; openModel.Connections[0].Welds.Add(weldData4); //add plate 3 IdeaRS.OpenModel.Connection.PlateData plateData3 = new IdeaRS.OpenModel.Connection.PlateData { Name = \"P3\", Thickness = 0.02, Id = 13, Material = \"S355\", OriginalModelId = \"13\", Origin = new IdeaRS.OpenModel.Geometry3D.Point3D { X = -2.103, Y = 2.88, Z = 3.1 }, AxisX = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 1, Y = 0, Z = 0 }, AxisY = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 0, Y = 1, Z = 0 }, AxisZ = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 0, Y = 0, Z = 1 }, Region = \"M 0 0 L 0.206 0 L 0.206 0.105 L 0.195 0.115 L 0.011 0.115 L 0.0 0.105 L 0 0\", }; openModel.Connections[0].Plates.Add(plateData3); //add weld between memeber 2 and plate 3 - stiffener IdeaRS.OpenModel.Connection.WeldData weldData2 = new IdeaRS.OpenModel.Connection.WeldData() { Id = 32, ConnectedPartIds = new List<string>() { plateData3.OriginalModelId, beam2Data.OriginalModelId }, Start = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2, Y = 2.995, Z = 3.11 }, End = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2, Y = 2.995, Z = 3.11 }, Thickness = 0.004, WeldType = IdeaRS.OpenModel.Connection.WeldType.DoubleFillet, }; openModel.Connections[0].Welds.Add(weldData2); //add weld5 between memeber 2 and plate 3 - stiffener IdeaRS.OpenModel.Connection.WeldData weldData5 = new IdeaRS.OpenModel.Connection.WeldData() { Id = 35, ConnectedPartIds = new List<string>() { plateData3.OriginalModelId, beam2Data.OriginalModelId }, Start = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2.103, Y = 2.90, Z = 3.11 }, End = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2.103, Y = 2.90, Z = 3.11 }, Thickness = 0.004, WeldType = IdeaRS.OpenModel.Connection.WeldType.DoubleFillet, }; openModel.Connections[0].Welds.Add(weldData5); //add weld6 between memeber 2 and plate 3 - stiffener IdeaRS.OpenModel.Connection.WeldData weldData6 = new IdeaRS.OpenModel.Connection.WeldData() { Id = 36, ConnectedPartIds = new List<string>() { plateData3.OriginalModelId, beam2Data.OriginalModelId }, Start = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -1.897, Y = 2.90, Z = 3.11 }, End = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -1.897, Y = 2.90, Z = 3.11 }, Thickness = 0.004, WeldType = IdeaRS.OpenModel.Connection.WeldType.DoubleFillet, }; openModel.Connections[0].Welds.Add(weldData6); //add plate 4 IdeaRS.OpenModel.Connection.PlateData plateData4 = new IdeaRS.OpenModel.Connection.PlateData { Name = \"P4\", Thickness = 0.02, Id = 14, Material = \"S355\", OriginalModelId = \"14\", Origin = new IdeaRS.OpenModel.Geometry3D.Point3D { X = -2.103, Y = 3.12, Z = 2.75 }, AxisX = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 1, Y = 0, Z = 0 }, AxisY = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 0, Y = -1, Z = 0 }, AxisZ = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 0, Y = 0, Z = 1 }, Region = \"M 0 0 L 0.206 0 L 0.206 0.105 L 0.195 0.115 L 0.011 0.115 L 0.0 0.105 L 0 0\", }; openModel.Connections[0].Plates.Add(plateData4); //add weld7 between memeber 2 and plate 4 - stiffener IdeaRS.OpenModel.Connection.WeldData weldData7 = new IdeaRS.OpenModel.Connection.WeldData() { Id = 37, ConnectedPartIds = new List<string>() { plateData4.OriginalModelId, beam2Data.OriginalModelId }, Start = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2, Y = 3.005, Z = 2.76 }, End = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2, Y = 3.005, Z = 2.76 }, Thickness = 0.004, WeldType = IdeaRS.OpenModel.Connection.WeldType.DoubleFillet, }; openModel.Connections[0].Welds.Add(weldData7); //add weld8 between memeber 2 and plate 4 - stiffener IdeaRS.OpenModel.Connection.WeldData weldData8 = new IdeaRS.OpenModel.Connection.WeldData() { Id = 38, ConnectedPartIds = new List<string>() { plateData4.OriginalModelId, beam2Data.OriginalModelId }, Start = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2.103, Y = 3.1, Z = 2.76 }, End = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2.103, Y = 3.1, Z = 2.76 }, Thickness = 0.004, WeldType = IdeaRS.OpenModel.Connection.WeldType.DoubleFillet, }; openModel.Connections[0].Welds.Add(weldData8); //add weld9 between memeber 2 and plate 4 - stiffener IdeaRS.OpenModel.Connection.WeldData weldData9 = new IdeaRS.OpenModel.Connection.WeldData() { Id = 39, ConnectedPartIds = new List<string>() { plateData4.OriginalModelId, beam2Data.OriginalModelId }, Start = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -1.897, Y = 3.1, Z = 2.76 }, End = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -1.897, Y = 3.1, Z = 2.76 }, Thickness = 0.004, WeldType = IdeaRS.OpenModel.Connection.WeldType.DoubleFillet, }; openModel.Connections[0].Welds.Add(weldData9); //add plate 5 IdeaRS.OpenModel.Connection.PlateData plateData5 = new IdeaRS.OpenModel.Connection.PlateData { Name = \"P5\", Thickness = 0.02, Id = 15, Material = \"S355\", OriginalModelId = \"15\", Origin = new IdeaRS.OpenModel.Geometry3D.Point3D { X = -2.103, Y = 3.12, Z = 3.1 }, AxisX = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 1, Y = 0, Z = 0 }, AxisY = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 0, Y = -1, Z = 0 }, AxisZ = new IdeaRS.OpenModel.Geometry3D.Vector3D { X = 0, Y = 0, Z = 1 }, Region = \"M 0 0 L 0.206 0 L 0.206 0.105 L 0.195 0.115 L 0.011 0.115 L 0.0 0.105 L 0 0\", }; openModel.Connections[0].Plates.Add(plateData5); //add weld10 between memeber 2 and plate 5 - stiffener IdeaRS.OpenModel.Connection.WeldData weldData10 = new IdeaRS.OpenModel.Connection.WeldData() { Id = 40, ConnectedPartIds = new List<string>() { plateData5.OriginalModelId, beam2Data.OriginalModelId }, Start = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2, Y = 3.005, Z = 3.11 }, End = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2, Y = 3.005, Z = 3.11 }, Thickness = 0.004, WeldType = IdeaRS.OpenModel.Connection.WeldType.DoubleFillet, }; openModel.Connections[0].Welds.Add(weldData10); //add weld11 between memeber 2 and plate 5 - stiffener IdeaRS.OpenModel.Connection.WeldData weldData11 = new IdeaRS.OpenModel.Connection.WeldData() { Id = 41, ConnectedPartIds = new List<string>() { plateData5.OriginalModelId, beam2Data.OriginalModelId }, Start = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2.103, Y = 3.10, Z = 3.11 }, End = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -2.103, Y = 3.10, Z = 3.11 }, Thickness = 0.004, WeldType = IdeaRS.OpenModel.Connection.WeldType.DoubleFillet, }; openModel.Connections[0].Welds.Add(weldData11); //add weld12 between memeber 2 and plate 5 - stiffener IdeaRS.OpenModel.Connection.WeldData weldData12 = new IdeaRS.OpenModel.Connection.WeldData() { Id = 46, ConnectedPartIds = new List<string>() { plateData5.OriginalModelId, beam2Data.OriginalModelId }, Start = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -1.897, Y = 3.10, Z = 3.11 }, End = new IdeaRS.OpenModel.Geometry3D.Point3D() { X = -1.897, Y = 3.10, Z = 3.11 }, Thickness = 0.004, WeldType = IdeaRS.OpenModel.Connection.WeldType.DoubleFillet, }; openModel.Connections[0].Welds.Add(weldData12); The IOM (.xml) is here."
  },
  "examples/iom/iom-rcs/IomToRcsExampleRunner/readme.html": {
    "href": "examples/iom/iom-rcs/IomToRcsExampleRunner/readme.html",
    "title": "IOM to RCS Example Runner | IDEA StatiCa API",
    "keywords": "IOM to RCS Example Runner This is a console application which uses the RCS API to convert a created IOM model containing RCS information into a RCS file (.ideaRcs)."
  },
  "examples/iom/iom-rcs/IomToRcsExamples/RcsColumn/rcs_column.html": {
    "href": "examples/iom/iom-rcs/IomToRcsExamples/RcsColumn/rcs_column.html",
    "title": "IOM Example - Concrete Column | IDEA StatiCa API",
    "keywords": "IOM Example - Concrete Column This example describes how to define a concrete column in IOM (IDEA StatiCa Open Model). Let's create a standard console application in MS Visual Studio. Select File > New > Project from the menu bar. In the dialog, select the Visual C# node followed by the Get Started node. Then select the Console App project template. Add the IdeaRS.OpenModel NuGet package OpenModel is published as the nuget package. To install this package, you can use either the Package Manager UI or the Package Manager Console. For more information, see Install and use a package in Visual Studio There is also documentation related to IdeaRS.OpenModel on Github. Create a new project IOM data has to contain basic information of a new project, such as a project name, description, code type etc. //Common project data var projectData = new ProjectData(); projectData.Name = \"Column project\"; projectData.Date = new DateTime(2019, 6, 4); //Additionl data for Ec var projectDataEc = new ProjectDataEc(); projectDataEc.AnnexCode = NationalAnnexCode.NoAnnex; projectDataEc.FatigueCheck = false; projectDataEc.FatigueAnnexNN = false; projectData.CodeDependentData = projectDataEc; openModel.ProjectData = projectData; //Concrete project data var projectDataConcrete = new ProjectDataConcreteEc2(); projectDataConcrete.CodeEN1992_2 = false; projectDataConcrete.CodeEN1992_3 = false; openModel.ProjectDataConcrete = projectDataConcrete; Materials To create a new project, these types of materials have to be created: a new concrete material //Concrete material MatConcreteEc2 mat = new MatConcreteEc2(); mat.Name = \"C30/37\"; mat.UnitMass = 2500.0; mat.E = 32836.6e6; mat.G = 13667000000.0; mat.Poisson = 0.2; mat.SpecificHeat = 0.6; mat.ThermalExpansion = 0.00001; mat.ThermalConductivity = 45; mat.Fck = 30.0e6; mat.CalculateDependentValues = true; openModel.AddObject(mat); a new material of reinforcement //Reinforcement material MatReinforcementEc2 matR = new MatReinforcementEc2(); matR.Name = \"B 500B\"; matR.UnitMass = 7850.0; matR.E = 200e9; matR.Poisson = 0.2; matR.G = 83.333e9; matR.SpecificHeat = 0.6; matR.ThermalExpansion = 0.00001; matR.ThermalConductivity = 45; matR.Fyk = 500e6; matR.CoeffFtkByFyk = 1.08; matR.Epsuk = 0.025; matR.Type = ReinfType.Bars; matR.BarSurface = ReinfBarSurface.Ribbed; matR.Class = ReinfClass.B; matR.Fabrication = ReinfFabrication.HotRolled; matR.DiagramType = ReinfDiagramType.BilinerWithAnInclinedTopBranch; openModel.AddObject(matR); Cross-section The next step is to define the shape and dimensions of cross-section and type of material. CrossSectionParameter css = new CrossSectionParameter(); //creating instance of cross-section defined by parameters css.Name = \"CSS 1\"; css.Id = openModel.GetMaxId(css) + 1; css.CrossSectionType = CrossSectionType.Rect; css.Parameters.Add(new ParameterDouble() { Name = \"Height\", Value = 0.5 }); css.Parameters.Add(new ParameterDouble() { Name = \"Width\", Value = 0.5 }); css.Material = new ReferenceElement(mat); openModel.AddObject(css); Reinforced cross-sections After defining the concrete cross-section, reinforcement is set into this one. The reinforced section is defined in this way and it is referenced to the concrete cross-section. A list of all reinforced cross-sections in project. //Reinforced section - concrete with reinforcement ReinforcedCrossSection rcs = new ReinforcedCrossSection(); rcs.Name = \"R 1\"; rcs.CrossSection = new ReferenceElement(css); openModel.AddObject(rcs); Reinforcement Reinforcement is define as stirrups and longitudinal bars. Longitudinal reinforcement Define position, material, diameter and quantity of longitudinal reinforcement. ReinforcedBar bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.1939; bar.Point.Y = 0.1939; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.1939; bar.Point.Y = -0.1939; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.1939; bar.Point.Y = -0.1939; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.1939; bar.Point.Y = 0.1939; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.0613; bar.Point.Y = -0.198; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.0613; bar.Point.Y = -0.198; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.0613; bar.Point.Y = 0.198; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.0613; bar.Point.Y = 0.198; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.198; bar.Point.Y = 0.0613; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.198; bar.Point.Y = -0.0613; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.198; bar.Point.Y = -0.0613; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.198; bar.Point.Y = 0.0613; rcs.Bars.Add(bar); Stirrups Setting shape, diameter and material of stirrup. var stirrup = new Stirrup(); stirrup.Diameter = 0.012; stirrup.DiameterOfMandrel = 4.0; stirrup.Distance = 0.2; stirrup.IsClosed = true; stirrup.Material = new ReferenceElement(matR); var poly = new PolyLine2D(); poly.StartPoint = new Point2D(); poly.StartPoint.X = -0.214; poly.StartPoint.Y = 0.214; var segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = -0.214; segment.EndPoint.Y = -0.214; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = 0.214; segment.EndPoint.Y = -0.214; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = 0.214; segment.EndPoint.Y = 0.214; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = -0.214; segment.EndPoint.Y = 0.214; poly.Segments.Add(segment); stirrup.Geometry = poly; rcs.Stirrups.Add(stirrup); Design member Design member contains information about whole checked member. In the first step, it is required to define design member and then the member data are set into the design member. var checkMember = new CheckMember1D(); //Design member data object openModel.AddObject(checkMember); Member data Setting of exposure classes, humidity and other important factors for the calculations (for example creep). //Concrete member data var memberData = new ConcreteMemberDataEc2(); //Member data base common object memberData.MemberType = ConcreteMemberType.Column; memberData.RelativeHumidity = 0.65; memberData.CreepCoeffInfinityValue = InputValue.Calculated; memberData.MemberImportance = MemberImportance.Major; memberData.ExposureClassesData = new ExposureClassesDataEc2(); //Exposure classes memberData.ExposureClassesData.NoCorrosionCheck = false; memberData.ExposureClassesData.CarbonationCheck = true; memberData.ExposureClassesData.Carbonation = ExposureClassEc2.XC3; memberData.ExposureClassesData.ChloridesCheck = true; memberData.ExposureClassesData.Chlorides = ExposureClassEc2.XD1; memberData.ExposureClassesData.ChloridesFromSeaCheck = false; memberData.ExposureClassesData.FreezeAttackCheck = false; memberData.ExposureClassesData.ChemicalAttackCheck = false; memberData.Element = new ReferenceElement(checkMember); openModel.AddObject(memberData); //Beam data are not necessary but must be created a default one memberData.BeamData = new BeamDataEc2(); Imperfections For calculation of second order effects, effective length of column and other parameters have to be set. //Concrete member data memberData.ColumnData = new ColumnDataEc2(); memberData.ColumnData.L = 3.0; memberData.ColumnData.EffectiveLength = InputValue.UserInput; memberData.ColumnData.L0Y = 3.0; memberData.ColumnData.L0Z = 3.0; memberData.ColumnData.SecondOrderEffectInput = InputValue.Calculated; memberData.ColumnData.GeometricImperfectionsULS = true; memberData.ColumnData.GeometricImperfectionsSLS = false; memberData.ColumnData.EffectConsidered = EffectConsideredType.IsolatedMember; memberData.ColumnData.ImperfectionDirection = ImperfectionDirection.FromSetup; memberData.ColumnData.Calculation2ndOrderEffect = true; memberData.ColumnData.BracedY = false; memberData.ColumnData.BracedZ = false; memberData.ColumnData.SecondOrderEffectMethod = SecondOrderEffectMethodEc2.NominalCurvature; memberData.ColumnData.ValueTypeOfcY = ValueTypec.UserDefined; memberData.ColumnData.UserValuecY = 9.8696; memberData.ColumnData.ValueTypeOfcZ = ValueTypec.UserDefined; memberData.ColumnData.UserValuecZ = 9.8696; Sections, Extremes, Internal forces, Second order effect The reinforced cross-section and the check member are defined for the checked section. Extremes of internal forces (for ULS and SLS calculation) are set in the checked section data there. For assessment of limit states, actual internal forces into the analyzed cross-section need to be insert. To calculate second order effects is necessary to insert the correct values of bending moment on the top and bottom of the column. //Standard section var singleCheckSection = new StandardCheckSection(); singleCheckSection.Description = \"S 1\"; singleCheckSection.ReinfSection = new ReferenceElement(rcs); singleCheckSection.CheckMember = new ReferenceElement(checkMember); //add extreme to section var sectionExtreme = new StandardCheckSectionExtreme(); sectionExtreme.Fundamental = new LoadingULS(); sectionExtreme.Fundamental.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = -3750.0e3, My = 112.7e3, Mz = -52.0e3 }; sectionExtreme.Fundamental.InternalForcesBegin = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { My = 22.0e3, Mz = -5.0e3 }; sectionExtreme.Fundamental.InternalForcesEnd = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { My = 18.0e3, Mz = 10.0e3 }; singleCheckSection.Extremes.Add(sectionExtreme); openModel.AddObject(singleCheckSection); Calculation control This setting define, which type of assessment will be used and corresponding results will be displayed. memberData.CalculationSetup = new CalculationSetup(); memberData.CalculationSetup.UlsDiagram = true; memberData.CalculationSetup.UlsShear = false; memberData.CalculationSetup.UlsTorsion = false; memberData.CalculationSetup.UlsInteraction = true; memberData.CalculationSetup.SlsStressLimitation = true; memberData.CalculationSetup.SlsCrack = true; memberData.CalculationSetup.Detailing = true; memberData.CalculationSetup.UlsResponse = true; memberData.CalculationSetup.SlsStiffnesses = false; memberData.CalculationSetup.MNKappaDiagram = false; Concrete setup Creating the code setup used for assessment of cross-section including national annex settings. //Concrete setup var setup = new ConcreteSetupEc2(); setup.Annex = NationalAnnexCode.NoAnnex; openModel.ConcreteSetup = setup; Results In the followed example there is way how to run the check and the get results. Results are stored in the object with considered values for each assessment. //Creating instance of Rcs controller var rcsController = new IdeaStatiCa.RcsController.IdeaRcsController(); System.Diagnostics.Debug.Assert(rcsController != null); //Assert.IsNotNull(rcsController); //Open rcs project from IOM IdeaRS.OpenModel.Message.OpenMessages messages; var ok = rcsController.OpenIdeaProjectFromIdeaOpenModel(openModel, \"Column\", out messages); System.Diagnostics.Debug.Assert(ok); rcsController.SaveAsIdeaProjectFile(fileName); //Calculate project ok = rcsController.Calculate(new List<int>() { singleCheckSection.Id }); System.Diagnostics.Debug.Assert(ok); //gets the results var result = rcsController.GetResultOnSection(null); System.Diagnostics.Debug.Assert(result != null); // Storing to standard xml file XmlSerializer xs = new XmlSerializer(typeof(List<IdeaRS.OpenModel.Concrete.CheckResult.SectionConcreteCheckResult>)); Stream fs = new FileStream(fileName, FileMode.Create); XmlTextWriter writer = new XmlTextWriter(fs, Encoding.Unicode); writer.Formatting = Formatting.Indented; // Serialize using the XmlTextWriter. xs.Serialize(writer, result); writer.Close(); fs.Close(); var sectionResult = result.FirstOrDefault(it => it.SectionId == singleCheckSection.Id); System.Diagnostics.Debug.Assert(result != null); foreach (var extremeResult in sectionResult.ExtremeResults) { var overalResult = extremeResult.Overall; foreach (var check in overalResult.Checks) { System.Diagnostics.Debug.WriteLine(\"{0} - {1} - {2}\", check.ResultType, check.Result, check.CheckValue); } foreach (var checkResult in extremeResult.CheckResults) { var checkType = checkResult.ResultType; foreach (var checkResult1 in checkResult.CheckResults) { var res = checkResult1.Result; switch (checkResult.ResultType) { case IdeaRS.OpenModel.Concrete.CheckResult.CheckResultType.Capacity: var resultCapacity = checkResult1 as IdeaRS.OpenModel.Concrete.CheckResult.ConcreteULSCheckResultDiagramCapacityEc2; var fu1 = resultCapacity.Fu1; var fu2 = resultCapacity.Fu2; break; case IdeaRS.OpenModel.Concrete.CheckResult.CheckResultType.Interaction: var resultInteraction = checkResult1 as IdeaRS.OpenModel.Concrete.CheckResult.ConcreteULSCheckResultInteractionEc2; var checkVT = resultInteraction.CheckValueShearAndTorsion; var checkVTB = resultInteraction.CheckValueShearTorsionAndBending; break; } if (checkResult1.NonConformities.Count > 0) { var issues = rcsController.GetNonConformityIssues(checkResult1.NonConformities.Select(it => it.Guid).ToList()); foreach (var issue in issues) { System.Diagnostics.Debug.WriteLine(issue.Description); } } } } } rcsController.Dispose();"
  },
  "examples/iom/iom-rcs/IomToRcsExamples/RcsPrestressedBeam/rcs_prestressed_beam.html": {
    "href": "examples/iom/iom-rcs/IomToRcsExamples/RcsPrestressedBeam/rcs_prestressed_beam.html",
    "title": "IOM Example - Prestressed Beam | IDEA StatiCa API",
    "keywords": "IOM Example - Prestressed Beam This example describes how to define a prestressed beam in IOM (IDEA StatiCa Open Model). Let's create a standard console application in MS Visual Studio. Select File > New > Project from the menu bar. In the dialog, select the Visual C# node followed by the Get Started node. Then select the Console App project template. Add the IdeaRS.OpenModel NuGet package OpenModel is published as the nuget package. To install this package, you can use either the Package Manager UI or the Package Manager Console. For more information, see Install and use a package in Visual Studio There is also documentation related to IdeaRS.OpenModel on Github. Create a new project IOM data has to contain basic information of a new project, such as a project name, description, code type etc. //Common project data var projectData = new ProjectData(); projectData.Name = \"Prestressed beam\"; projectData.Date = new DateTime(2019, 6, 4); //Additionl data for Ec var projectDataEc = new ProjectDataEc(); projectDataEc.AnnexCode = NationalAnnexCode.NoAnnex; projectDataEc.FatigueCheck = false; projectDataEc.FatigueAnnexNN = false; projectData.CodeDependentData = projectDataEc; openModel.ProjectData = projectData; //Concrete project data var projectDataConcrete = new ProjectDataConcreteEc2(); projectDataConcrete.CodeEN1992_2 = false; projectDataConcrete.CodeEN1992_3 = false; openModel.ProjectDataConcrete = projectDataConcrete; Materials To create a new project, these types of materials have to be defined: a new concrete material //Concrete material MatConcreteEc2 mat = new MatConcreteEc2(); mat.Name = \"C30/37\"; mat.UnitMass = 2500.0; mat.E = 32836.6e6; mat.G = 13667000000.0; mat.Poisson = 0.2; mat.SpecificHeat = 0.6; mat.ThermalExpansion = 0.00001; mat.ThermalConductivity = 45; mat.Fck = Conversions.MPaToSystem(30.0); mat.CalculateDependentValues = true; openModel.AddObject(mat); a new material of reinforcement //Reinforcement material MatReinforcementEc2 matR = new MatReinforcementEc2(); matR.Name = \"B 500B\"; matR.UnitMass = 7850.0; matR.E = Conversions.GPaToSystem(200); matR.Poisson = 0.2; matR.G = Conversions.GPaToSystem(83.333); matR.SpecificHeat = 0.6; matR.ThermalExpansion = 0.00001; matR.ThermalConductivity = 45; matR.Fyk = Conversions.MPaToSystem(500); matR.CoeffFtkByFyk = 1.08; matR.Epsuk = 0.025; matR.Type = ReinfType.Bars; matR.BarSurface = ReinfBarSurface.Ribbed; matR.Class = ReinfClass.B; matR.Fabrication = ReinfFabrication.HotRolled; matR.DiagramType = ReinfDiagramType.BilinerWithAnInclinedTopBranch; openModel.AddObject(matR); a new material of prestressing reinforcement //Prestressing material MatPrestressSteelEc2 matP = new MatPrestressSteelEc2(); matP.Name = \"Y1860S7-15.7\"; matP.UnitMass = 7850.0; matP.E = Conversions.GPaToSystem(195); matP.Poisson = 0.2; matP.G = Conversions.GPaToSystem(83.333); matP.SpecificHeat = 0.6; matP.ThermalExpansion = 0.00001; matP.ThermalConductivity = 45; matP.Diameter = 0.0157; matP.Area = 0.000150; matP.NumberOfWires = 7; matP.Fpk = Conversions.MPaToSystem(1860); matP.Fp01k = Conversions.MPaToSystem(1640); matP.Epsuk = 0.035; matP.Type = PrestressSteelType.Strand; matP.SurfaceCharacteristic = SurfaceCharacteristicType.Plain; matP.Production = ProductionType.LowRelaxation; matP.DiagramType = ReinfDiagramType.BilinerWithAnInclinedTopBranch; openModel.AddObject(matP); Cross-section The next step is to define the shape and dimensions of cross-section and type of material. CrossSectionParameter css = new CrossSectionParameter(); css.Name = \"S 1\"; css.Id = openModel.GetMaxId(css) + 1; css.CrossSectionType = CrossSectionType.BeamShapeIHaunchChamferAssym; css.Parameters.Add(new ParameterDouble() { Name = \"Bbf\", Value = 0.4 }); css.Parameters.Add(new ParameterDouble() { Name = \"Hbf\", Value = 0.2 }); css.Parameters.Add(new ParameterDouble() { Name = \"Hbfh\", Value = 0.075 }); css.Parameters.Add(new ParameterDouble() { Name = \"Bw\", Value = 0.2 }); css.Parameters.Add(new ParameterDouble() { Name = \"Bwh\", Value = 0.05 }); css.Parameters.Add(new ParameterDouble() { Name = \"H\", Value = 1.2 }); css.Parameters.Add(new ParameterDouble() { Name = \"Htfh\", Value = 0.05 }); css.Parameters.Add(new ParameterDouble() { Name = \"Htf\", Value = 0.175 }); css.Parameters.Add(new ParameterDouble() { Name = \"Btfl\", Value = 0.5 }); css.Parameters.Add(new ParameterDouble() { Name = \"Btfr\", Value = 0.5 }); openModel.AddObject(css); Reinforced cross-sections After defining the concrete cross-section, reinforcement is set into this one. The reinforced section is defined in this way and it is referenced to the concrete cross-section. //Reinforced section - concrete with reinforcement ReinforcedCrossSection rcs = new ReinforcedCrossSection(); rcs.Name = \"RS 1\"; rcs.CrossSection = new ReferenceElement(css); Reinforcement Reinforcement is defined as stirrups and longitudinal bars. Longitudinal reinforcement Define position, material, diameter and quantity of longitudinal reinforcement. //Reinforcement ReinforcedBar bar = new ReinforcedBar(); bar.Diameter = 0.025; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.146; bar.Point.Y = -0.7088; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.025; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.046; bar.Point.Y = -0.7088; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.025; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.046; bar.Point.Y = -0.7088; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.025; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.146; bar.Point.Y = -0.7088; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.150; bar.Point.Y = -0.5893; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.150; bar.Point.Y = -0.5893; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.056; bar.Point.Y = 0.2847; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.056; bar.Point.Y = 0.094; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.056; bar.Point.Y = -0.0968; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.056; bar.Point.Y = -0.2876; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.056; bar.Point.Y = -0.4783; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.056; bar.Point.Y = -0.4783; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.056; bar.Point.Y = -0.2876; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.056; bar.Point.Y = -0.0968; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.056; bar.Point.Y = 0.094; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.056; bar.Point.Y = 0.2847; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.596; bar.Point.Y = 0.3967; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.321; bar.Point.Y = 0.3967; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.046; bar.Point.Y = 0.3967; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.046; bar.Point.Y = 0.3967; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.321; bar.Point.Y = 0.3967; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.596; bar.Point.Y = 0.3967; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.599; bar.Point.Y = 0.3097; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.324; bar.Point.Y = 0.3097; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.324; bar.Point.Y = 0.3097; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.599; bar.Point.Y = 0.3097; rcs.Bars.Add(bar); Stirrups Setting shape and material of stirrup. var stirrup = new Stirrup(); stirrup.Diameter = 0.008; stirrup.DiameterOfMandrel = 4.0; stirrup.Distance = 0.2; stirrup.IsClosed = true; stirrup.Material = new ReferenceElement(matR); stirrup.ShearCheck = true; stirrup.TorsionCheck = true; var poly = new PolyLine2D(); poly.StartPoint = new Point2D(); poly.StartPoint.X = -0.066; poly.StartPoint.Y = 0.4067; var segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = -0.066; segment.EndPoint.Y = -0.7253; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = 0.066; segment.EndPoint.Y = -0.7253; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = 0.066; segment.EndPoint.Y = 0.4067; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = -0.066; segment.EndPoint.Y = 0.4067; poly.Segments.Add(segment); stirrup.Geometry = poly; rcs.Stirrups.Add(stirrup); stirrup = new Stirrup(); stirrup.Diameter = 0.008; stirrup.DiameterOfMandrel = 4.0; stirrup.Distance = 0.2; stirrup.IsClosed = true; stirrup.ShearCheck = false; stirrup.TorsionCheck = false; stirrup.Material = new ReferenceElement(matR); poly = new PolyLine2D(); poly.StartPoint = new Point2D(); poly.StartPoint.X = -0.616; poly.StartPoint.Y = 0.4067; segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = 0.616; segment.EndPoint.Y = 0.4067; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = 0.616; segment.EndPoint.Y = 0.2997; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = -0.616; segment.EndPoint.Y = 0.2997; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = -0.616; segment.EndPoint.Y = 0.4067; poly.Segments.Add(segment); stirrup.Geometry = poly; rcs.Stirrups.Add(stirrup); stirrup = new Stirrup(); stirrup.Diameter = 0.008; stirrup.DiameterOfMandrel = 4.0; stirrup.Distance = 0.2; stirrup.IsClosed = false; stirrup.ShearCheck = false; stirrup.TorsionCheck = false; stirrup.Material = new ReferenceElement(matR); poly = new PolyLine2D(); poly.StartPoint = new Point2D(); poly.StartPoint.X = 0.066; poly.StartPoint.Y = -0.4023; segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = -0.166; segment.EndPoint.Y = -0.5763; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = -0.166; segment.EndPoint.Y = -0.7253; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = 0.166; segment.EndPoint.Y = -0.7253; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = 0.166; segment.EndPoint.Y = -0.5763; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = -0.066; segment.EndPoint.Y = -0.4023; poly.Segments.Add(segment); stirrup.Geometry = poly; rcs.Stirrups.Add(stirrup); openModel.AddObject(rcs); Prestressing For prestressed member, it is necessary to set position and type of tendons. Material and quantity of strands in tendon, material and diameter of ducts is need to be set. //Tendon TendonBar tendonBar = new TendonBar(); tendonBar.Material = new ReferenceElement(matP); tendonBar.NumStrandsInTendon = 5; tendonBar.Phase = 0; tendonBar.PrestressingOrder = 1; tendonBar.PrestressReinforcementType = FatigueTypeOfPrestressingSteel.PostTensioningSingleStrandsInPlasticDucts; tendonBar.TendonType = TendonBarType.Posttensioned; tendonBar.Id = 1; tendonBar.Point = new Point2D() { X = 0.0, Y = -0.6493 }; rcs.TendonBars.Add(tendonBar); TendonDuct tendonDuct = new TendonDuct(); tendonDuct.Diameter = 0.05; tendonDuct.MaterialDuct = MaterialDuct.Plastic; tendonDuct.Id = 1; tendonDuct.Point = new Point2D() { X = 0.0, Y = -0.6493 }; tendonBar.TendonDuct = tendonDuct; Design member Design member contains information about whole checked member. In the first step, it is required to define design member and then the member data are set into the design member. //Check member == Design member in the RCS var checkMember = new CheckMember1D(); openModel.AddObject(checkMember); Member data Setting of exposure classes, humidity and other important factors for the calculations (for example creep). //Concrete meber data var memberData = new ConcreteMemberDataEc2(); memberData.Element = new ReferenceElement(checkMember); openModel.AddObject(memberData); memberData.MemberType = ConcreteMemberType.Beam; memberData.RelativeHumidity = 0.65; memberData.CreepCoeffInfinityValue = InputValue.Calculated; memberData.MemberImportance = MemberImportance.Major; memberData.CalculationSetup = new CalculationSetup(); memberData.CalculationSetup.UlsDiagram = true; memberData.CalculationSetup.UlsShear = true; memberData.CalculationSetup.UlsTorsion = true; memberData.CalculationSetup.UlsInteraction = true; memberData.CalculationSetup.SlsStressLimitation = true; memberData.CalculationSetup.SlsCrack = true; memberData.CalculationSetup.Detailing = true; memberData.CalculationSetup.UlsResponse = false; memberData.CalculationSetup.SlsStiffnesses = false; memberData.CalculationSetup.MNKappaDiagram = false; memberData.ColumnData = new ColumnDataEc2(); memberData.ExposureClassesData = new ExposureClassesDataEc2(); memberData.ExposureClassesData.NoCorrosionCheck = false; memberData.ExposureClassesData.CarbonationCheck = true; memberData.ExposureClassesData.Carbonation = ExposureClassEc2.XC3; memberData.ExposureClassesData.ChloridesCheck = true; memberData.ExposureClassesData.Chlorides = ExposureClassEc2.XD1; memberData.ExposureClassesData.ChloridesFromSeaCheck = false; memberData.ExposureClassesData.FreezeAttackCheck = false; memberData.ExposureClassesData.ChemicalAttackCheck = false; memberData.BeamData = new BeamDataEc2(); memberData.BeamData.Ln = 1.0; memberData.BeamData.TypeOfSupportLeft = TypeOfSupportConditions.NonContinuous; memberData.BeamData.TypeOfSupportRight = TypeOfSupportConditions.NonContinuous; memberData.BeamData.WidthOfSupportLeft = 0.4; memberData.BeamData.WidthOfSupportRight = 0.4; Construction stages In this tab, it is necessary to set each time of construction stages to calculate creep, loses in tendons etc. It is very important to set time of prestressing for prestressed members. memberData.TimeAxis = new TimeAxis(); TimePoint tp = new TimePoint(); tp.Age = 0.0; tp.Name = \"Casting\"; tp.Stage = true; tp.Prestressing = false; tp.Time = Conversions.DaysToSystem(0.0); memberData.TimeAxis.Times.Add(tp); tp = new TimePoint(); tp.Age = 0.0; tp.Name = \"Post-tensioning\"; tp.Stage = false; tp.Prestressing = true; tp.Time = Conversions.DaysToSystem(28.0); memberData.TimeAxis.Times.Add(tp); tp = new TimePoint(); tp.Age = 0.0; tp.Name = \"Superimposed dead load\"; tp.Stage = false; tp.Prestressing = false; tp.Time = Conversions.DaysToSystem(60.0); memberData.TimeAxis.Times.Add(tp); tp = new TimePoint(); tp.Age = 0.0; tp.Name = \"End of design working life\"; tp.Stage = false; tp.Prestressing = false; tp.Time = Conversions.DaysToSystem(18250.0); memberData.TimeAxis.Times.Add(tp); Sections, Extremes, Internal forces The reinforced cross-section and the check member are defined for the checked section. Extremes of internal forces (for ULS and SLS calculation) are set in to the checked section data there. For assessment of limit states, actual internal forces into the analyzed cross-section need to be insert. Effect of prestressing is calculated automatically. //Staged section var stagedCheckSection = new StagedCheckSection(); stagedCheckSection.Description = \"Section 1\"; stagedCheckSection.ReinfSection = new ReferenceElement(rcs); stagedCheckSection.CheckMember = new ReferenceElement(checkMember); openModel.AddObject(stagedCheckSection); Action stages In the next step it is required to insert initial state of cross-section. It is defined as total effects of characteristic permanent load, prestressing, and creep and shrinkage of concrete related to origin of coordinate systém. In case of statically indeterminate structure is necessary to insert secondary effects of prestressing. //Stages var stagesLoading = new StagesLoading(); stagedCheckSection.StagesLoading = stagesLoading; stagesLoading.PrestressInputType = PrestressInputType.AfterLongTermLosses; stagesLoading.CssEffectType = CssEffectType.InternalForce; //component loading var cssComponentLoading = new CssComponentLoading(); cssComponentLoading.Id = 1; var cssComponentTimeLoading = new CssComponentTimeLoading(); cssComponentTimeLoading.Time = Conversions.DaysToSystem(28.0); cssComponentTimeLoading.Loading = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = -996.4e3, My = -317.7e3 }; cssComponentLoading.Loading.Add(cssComponentTimeLoading); cssComponentTimeLoading = new CssComponentTimeLoading(); cssComponentTimeLoading.Time = Conversions.DaysToSystem(60.0); cssComponentTimeLoading.Loading = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = -996.1e3, My = -32.7e3 }; cssComponentLoading.Loading.Add(cssComponentTimeLoading); cssComponentTimeLoading = new CssComponentTimeLoading(); cssComponentTimeLoading.Time = Conversions.DaysToSystem(18250.0); cssComponentTimeLoading.Loading = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = -846.8e3, My = 64.3e3 }; cssComponentLoading.Loading.Add(cssComponentTimeLoading); stagesLoading.CssComponentLoad.Add(cssComponentLoading); //prestress loading var prestressLoading = new PrestressLoading(); prestressLoading.Time = Conversions.DaysToSystem(28.0); prestressLoading.PrimaryForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces(); prestressLoading.SecondaryForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = -0.1e3, My = -3.6e3 }; stagesLoading.PrestressLoad.Add(prestressLoading); prestressLoading = new PrestressLoading(); prestressLoading.Time = Conversions.DaysToSystem(60.0); prestressLoading.PrimaryForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces(); prestressLoading.SecondaryForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 0.0 }; stagesLoading.PrestressLoad.Add(prestressLoading); prestressLoading = new PrestressLoading(); prestressLoading.Time = Conversions.DaysToSystem(18250.0); prestressLoading.PrimaryForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces(); prestressLoading.SecondaryForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 0.0 }; stagesLoading.PrestressLoad.Add(prestressLoading); var tendonComponentLoading = new TendonComponentLoading(); tendonComponentLoading.Id = 1; var tendonStressLoading = new TendonStressLoading(); var tendonTimeStressLoading = new TendonTimeStressLoading(); tendonTimeStressLoading.Time = Conversions.DaysToSystem(28.0); tendonTimeStressLoading.Stress = Conversions.MPaToSystem(1328.4); tendonStressLoading.Stresses.Add(tendonTimeStressLoading); tendonTimeStressLoading = new TendonTimeStressLoading(); tendonTimeStressLoading.Time = Conversions.DaysToSystem(60.0); tendonTimeStressLoading.Stress = Conversions.MPaToSystem(1328.1); tendonStressLoading.Stresses.Add(tendonTimeStressLoading); tendonTimeStressLoading = new TendonTimeStressLoading(); tendonTimeStressLoading.Time = Conversions.DaysToSystem(18250.0); tendonTimeStressLoading.Stress = Conversions.MPaToSystem(1129.1); tendonStressLoading.Stresses.Add(tendonTimeStressLoading); tendonComponentLoading.Loading = tendonStressLoading; stagesLoading.TendonComponentLoad.Add(tendonComponentLoading); Creating extremes //add extreme to section var sectionExtreme = new StagedCheckSectionExtreme(); sectionExtreme.Time = Conversions.DaysToSystem(28.0); sectionExtreme.Fundamental = new LoadingULS(); sectionExtreme.Fundamental.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 332.8e3, Qz = 0.0 }; sectionExtreme.Fundamental.InternalForcesVariable = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 0.0, Qz = 0.0 }; sectionExtreme.Characteristic = new LoadingSLS(); sectionExtreme.Characteristic.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 332.8e3, Qz = 0.0 }; sectionExtreme.Characteristic.InternalForcesVariable = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 0.0, Qz = 0.0 }; sectionExtreme.Frequent = new LoadingSLS(); sectionExtreme.Frequent.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 332.8e3, Qz = 0.0 }; sectionExtreme.Frequent.InternalForcesVariable = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 0.0, Qz = 0.0 }; sectionExtreme.QuasiPermanent = new LoadingSLS(); sectionExtreme.QuasiPermanent.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 332.8e3, Qz = 0.0 }; sectionExtreme.QuasiPermanent.InternalForcesVariable = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 0.0, Qz = 0.0 }; stagedCheckSection.Extremes.Add(sectionExtreme); sectionExtreme = new StagedCheckSectionExtreme(); sectionExtreme.Time = Conversions.DaysToSystem(28.0); sectionExtreme.Fundamental = new LoadingULS(); sectionExtreme.Fundamental.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 449.3e3, Qz = 0.0 }; sectionExtreme.Fundamental.InternalForcesVariable = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 0.0, Qz = 0.0 }; stagedCheckSection.Extremes.Add(sectionExtreme); sectionExtreme = new StagedCheckSectionExtreme(); sectionExtreme.Time = Conversions.DaysToSystem(18250.0); sectionExtreme.Fundamental = new LoadingULS(); sectionExtreme.Fundamental.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 614.1e3, Qz = 0.0 }; sectionExtreme.Fundamental.InternalForcesVariable = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 0.0, Qz = 0.0 }; sectionExtreme.Characteristic = new LoadingSLS(); sectionExtreme.Characteristic.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 614.1e3, Qz = 0.0 }; sectionExtreme.Characteristic.InternalForcesVariable = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 0.0, Qz = 0.0 }; sectionExtreme.Frequent = new LoadingSLS(); sectionExtreme.Frequent.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 614.1e3, Qz = 0.0 }; sectionExtreme.Frequent.InternalForcesVariable = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 0.0, Qz = 0.0 }; sectionExtreme.QuasiPermanent = new LoadingSLS(); sectionExtreme.QuasiPermanent.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 614.1e3, Qz = 0.0 }; sectionExtreme.QuasiPermanent.InternalForcesVariable = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 0.0, Qz = 0.0 }; stagedCheckSection.Extremes.Add(sectionExtreme); sectionExtreme = new StagedCheckSectionExtreme(); sectionExtreme.Time = Conversions.DaysToSystem(18250.0); sectionExtreme.Fundamental = new LoadingULS(); sectionExtreme.Fundamental.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 704.6e3, Qz = 0.0 }; sectionExtreme.Fundamental.InternalForcesVariable = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 632.8e3, Qz = 0.0 }; sectionExtreme.Characteristic = new LoadingSLS(); sectionExtreme.Characteristic.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 614.1e3, Qz = 0.0 }; sectionExtreme.Characteristic.InternalForcesVariable = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 421.9e3, Qz = 0.0 }; sectionExtreme.Frequent = new LoadingSLS(); sectionExtreme.Frequent.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 614.1e3, Qz = 0.0 }; sectionExtreme.Frequent.InternalForcesVariable = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 210.9e3, Qz = 0.0 }; sectionExtreme.QuasiPermanent = new LoadingSLS(); sectionExtreme.QuasiPermanent.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 614.1e3, Qz = 0.0 }; sectionExtreme.QuasiPermanent.InternalForcesVariable = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 126.6e3, Qz = 0.0 }; stagedCheckSection.Extremes.Add(sectionExtreme); sectionExtreme = new StagedCheckSectionExtreme(); sectionExtreme.Time = Conversions.DaysToSystem(18250.0); sectionExtreme.Fundamental = new LoadingULS(); sectionExtreme.Fundamental.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 614.1e3, Qz = 0.0 }; sectionExtreme.Fundamental.InternalForcesVariable = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 632.8e3, Qz = 0.0 }; stagedCheckSection.Extremes.Add(sectionExtreme); Calculation control This setting define, which type of assessment will be used and corresponding results will be displayed. memberData.CalculationSetup = new CalculationSetup(); memberData.CalculationSetup.UlsDiagram = true; memberData.CalculationSetup.UlsShear = true; memberData.CalculationSetup.UlsTorsion = true; memberData.CalculationSetup.UlsInteraction = true; memberData.CalculationSetup.SlsStressLimitation = true; memberData.CalculationSetup.SlsCrack = true; memberData.CalculationSetup.Detailing = true; memberData.CalculationSetup.UlsResponse = false; memberData.CalculationSetup.SlsStiffnesses = false; memberData.CalculationSetup.MNKappaDiagram = false; Concrete setup Creating the code setup used for assessment of the cross-section including national annex settings. //Concrete setup var setup = new ConcreteSetupEc2(); setup.Annex = NationalAnnexCode.NoAnnex; openModel.ConcreteSetup = setup; Results In the followed example there is way how to run the check and the get results. Results are stored in the object with considered values for each assessment. //Creating instance of Rcs controller var rcsController = new IdeaStatiCa.RcsController.IdeaRcsController(); //Open rcs project from IOM IdeaRS.OpenModel.Message.OpenMessages messages; var ok = rcsController.OpenIdeaProjectFromIdeaOpenModel(openModel, \"ProjectName\", out messages); //Calculate project ok = rcsController.Calculate(null); //gets the results var result = rcsController.GetResultOnSection(null); var sectionResult = result.FirstOrDefault(it => it.SectionId == stagedCheckSection.Id); foreach (var extremeResult in sectionResult.ExtremeResults) { foreach (var checkResult in extremeResult.CheckResults) { var checkType = checkResult.ResultType; foreach (var checkResult1 in checkResult.CheckResults) { var res = checkResult1.Result; switch (checkResult.ResultType) { case IdeaRS.OpenModel.Concrete.CheckResult.CheckResultType.Capacity: var resultCapacity = checkResult1 as IdeaRS.OpenModel.Concrete.CheckResult.ConcreteULSCheckResultDiagramCapacityEc2; var fu1 = resultCapacity.Fu1; var fu2 = resultCapacity.Fu2; //.... break; case IdeaRS.OpenModel.Concrete.CheckResult.CheckResultType.Interaction: var resultInteraction = checkResult1 as IdeaRS.OpenModel.Concrete.CheckResult.ConcreteULSCheckResultInteractionEc2; var checkVT = resultInteraction.CheckValueShearAndTorsion; var checkVTB = resultInteraction.CheckValueShearTorsionAndBending; //.... break; case IdeaRS.OpenModel.Concrete.CheckResult.CheckResultType.Shear: var resultShear = checkResult1 as IdeaRS.OpenModel.Concrete.CheckResult.ConcreteULSCheckResultShearEc2; var v_ed = resultShear.Ved; var v_rdc = resultShear.Vrdc; //.... break; case IdeaRS.OpenModel.Concrete.CheckResult.CheckResultType.CrackWidth: var resultCrackWidth = checkResult1 as IdeaRS.OpenModel.Concrete.CheckResult.ConcreteSLSCheckResultCrackWidthEc2; var w = resultCrackWidth.W; var wlim = resultCrackWidth.Wlim; //.... break; } if (checkResult1.NonConformities.Count > 0) { var issues = rcsController.GetNonConformityIssues(checkResult1.NonConformities.Select(it => it.Guid).ToList()); foreach (var issue in issues) { var text = issue.Description; //.... } } } } } rcsController.Dispose();"
  },
  "examples/iom/iom-rcs/IomToRcsExamples/RcsReinforcedBeam/rcs_reinforced_beam.html": {
    "href": "examples/iom/iom-rcs/IomToRcsExamples/RcsReinforcedBeam/rcs_reinforced_beam.html",
    "title": "IOM Example - Reinforced Beam | IDEA StatiCa API",
    "keywords": "IOM Example - Reinforced Beam This example describes how to define a reinforced beam in IOM (IDEA StatiCa Open Model). Let's create a standard console application in MS Visual Studio. Select File > New > Project from the menu bar. In the dialog, select the Visual C# node followed by the Get Started node. Then select the Console App project template. Add the IdeaRS.OpenModel NuGet package OpenModel is published as the nuget package. To install this package, you can use either the Package Manager UI or the Package Manager Console. For more information, see Install and use a package in Visual Studio There is also documentation related to IdeaRS.OpenModel on Github. Create a new project IOM data has to contain basic information of a new project, such as a project name, description, code type etc. //Common project data var projectData = new ProjectData(); projectData.Name = \"Column project\"; projectData.Date = new DateTime(2019, 6, 4); //Additionl data for Ec var projectDataEc = new ProjectDataEc(); projectDataEc.AnnexCode = NationalAnnexCode.NoAnnex; projectDataEc.FatigueCheck = false; projectDataEc.FatigueAnnexNN = false; projectData.CodeDependentData = projectDataEc; openModel.ProjectData = projectData; //Concrete project data var projectDataConcrete = new ProjectDataConcreteEc2(); projectDataConcrete.CodeEN1992_2 = false; projectDataConcrete.CodeEN1992_3 = false; openModel.ProjectDataConcrete = projectDataConcrete; Materials To create a new project, these types of materials have to be defined: a new concrete material //Concrete material MatConcreteEc2 mat = new MatConcreteEc2(); mat.Name = \"C30/37\"; mat.UnitMass = 2500.0; mat.E = 32836.6e6; mat.G = 13667000000.0; mat.Poisson = 0.2; mat.SpecificHeat = 0.6; mat.ThermalExpansion = 0.00001; mat.ThermalConductivity = 45; mat.Fck = Conversions.MPaToSystem(30.0); mat.CalculateDependentValues = true; openModel.AddObject(mat); a new material of reinforcement //Reinforcement material MatReinforcementEc2 matR = new MatReinforcementEc2(); matR.Name = \"B 500B\"; matR.UnitMass = 7850.0; matR.E = 200e9; matR.Poisson = 0.2; matR.G = 83.333e9; matR.SpecificHeat = 0.6; matR.ThermalExpansion = 0.00001; matR.ThermalConductivity = 45; matR.Fyk = 500e6; matR.CoeffFtkByFyk = 1.08; matR.Epsuk = 0.025; matR.Type = ReinfType.Bars; matR.BarSurface = ReinfBarSurface.Ribbed; matR.Class = ReinfClass.B; matR.Fabrication = ReinfFabrication.HotRolled; matR.DiagramType = ReinfDiagramType.BilinerWithAnInclinedTopBranch; openModel.AddObject(matR); Cross-section The next step is to define the shape and dimensions of cross-section and type of material. Reinforced cross-sections After defining the concrete cross-section, reinforcement is set into this one. The reinforced section is defined in this way and it is referenced to the concrete cross-section. CrossSectionParameter css = new CrossSectionParameter(); css.Name = \"CSS1\"; css.Id = openModel.GetMaxId(css) + 1; css.CrossSectionType = CrossSectionType.Tg; css.Parameters.Add(new ParameterDouble() { Name = \"Height\", Value = 0.7 }); css.Parameters.Add(new ParameterDouble() { Name = \"Width\", Value = 0.8 }); css.Parameters.Add(new ParameterDouble() { Name = \"TopFlangeWidth\", Value = 0.16 }); css.Parameters.Add(new ParameterDouble() { Name = \"WallWidth\", Value = 0.25 }); css.Material = new ReferenceElement(mat); openModel.AddObject(css); Reinforcement Reinforcement is defined as stirrups and longitudinal bars. //Reinforced section - concrete with reinforcement ReinforcedCrossSection rcs = new ReinforcedCrossSection(); rcs.Name = \"R 1\"; rcs.CrossSection = new ReferenceElement(css); openModel.AddObject(rcs); Longitudinal reinforcement Define position, material, diameter and quantity of longitudinal reinforcement. //Reinforced section - concrete with reinforcement ReinforcedCrossSection rcs = new ReinforcedCrossSection(); rcs.Name = \"R 1\"; rcs.CrossSection = new ReferenceElement(css); ReinforcedBar bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.346; bar.Point.Y = 0.2157; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.071; bar.Point.Y = 0.2157; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.071; bar.Point.Y = 0.2157; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.346; bar.Point.Y = 0.2157; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.071; bar.Point.Y = -0.3923; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.020; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.071; bar.Point.Y = -0.3923; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.346; bar.Point.Y = 0.1437; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.346; bar.Point.Y = 0.1437; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.079; bar.Point.Y = -0.0063; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = -0.079; bar.Point.Y = -0.2343; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.079; bar.Point.Y = -0.2343; rcs.Bars.Add(bar); bar = new ReinforcedBar(); bar.Diameter = 0.012; bar.Material = new ReferenceElement(matR); bar.Point = new Point2D(); bar.Point.X = 0.079; bar.Point.Y = -0.0063; rcs.Bars.Add(bar); Stirrups Setting shape and material of stirrup. var stirrup = new Stirrup(); stirrup.Diameter = 0.008; stirrup.DiameterOfMandrel = 4.0; stirrup.Distance = 0.15; stirrup.IsClosed = true; stirrup.Material = new ReferenceElement(matR); stirrup.ShearCheck = true; stirrup.TorsionCheck = true; var poly = new PolyLine2D(); poly.StartPoint = new Point2D(); poly.StartPoint.X = -0.091; poly.StartPoint.Y = 0.2257; var segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = -0.091; segment.EndPoint.Y = -0.4063; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = 0.091; segment.EndPoint.Y = -0.4063; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = 0.091; segment.EndPoint.Y = 0.2257; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = -0.091; segment.EndPoint.Y = 0.2257; poly.Segments.Add(segment); stirrup.Geometry = poly; rcs.Stirrups.Add(stirrup); stirrup = new Stirrup(); stirrup.Diameter = 0.008; stirrup.DiameterOfMandrel = 4.0; stirrup.Distance = 0.15; stirrup.IsClosed = true; stirrup.ShearCheck = true; stirrup.TorsionCheck = false; stirrup.Material = new ReferenceElement(matR); poly = new PolyLine2D(); poly.StartPoint = new Point2D(); poly.StartPoint.X = -0.366; poly.StartPoint.Y = 0.2257; segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = -0.366; segment.EndPoint.Y = 0.1337; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = 0.366; segment.EndPoint.Y = 0.1337; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = 0.366; segment.EndPoint.Y = 0.2257; poly.Segments.Add(segment); segment = new LineSegment2D(); segment.EndPoint = new Point2D(); segment.EndPoint.X = -0.366; segment.EndPoint.Y = 0.2257; poly.Segments.Add(segment); stirrup.Geometry = poly; rcs.Stirrups.Add(stirrup); Design member Design member contains information about whole checked member. In the first step, it is required to define design member and then the member data are set into the design member. //Check member == Design member in the RCS var checkMember = new CheckMember1D(); openModel.AddObject(checkMember); Member data Setting of exposure classes, humidity and other important factors for the calculations (for example creep). //Concrete meber data var memberData = new ConcreteMemberDataEc2(); memberData.MemberType = ConcreteMemberType.Beam; memberData.RelativeHumidity = 0.65; memberData.CreepCoeffInfinityValue = InputValue.Calculated; memberData.MemberImportance = MemberImportance.Major; memberData.ColumnData = new ColumnDataEc2(); memberData.ExposureClassesData = new ExposureClassesDataEc2(); memberData.ExposureClassesData.NoCorrosionCheck = false; memberData.ExposureClassesData.CarbonationCheck = true; memberData.ExposureClassesData.Carbonation = ExposureClassEc2.XC3; memberData.ExposureClassesData.ChloridesCheck = true; memberData.ExposureClassesData.Chlorides = ExposureClassEc2.XD1; memberData.ExposureClassesData.ChloridesFromSeaCheck = false; memberData.ExposureClassesData.FreezeAttackCheck = false; memberData.ExposureClassesData.ChemicalAttackCheck = false; memberData.Element = new ReferenceElement(checkMember); openModel.AddObject(memberData); Flectural slendeness In this dialog, it is required to set clear distance between faces of the supports and support conditions to check deflection of the beam. memberData.BeamData = new BeamDataEc2(); memberData.BeamData.Ln = 1.0; memberData.BeamData.TypeOfSupportLeft = TypeOfSupportConditions.NonContinuous; memberData.BeamData.TypeOfSupportRight = TypeOfSupportConditions.NonContinuous; memberData.BeamData.WidthOfSupportLeft = 0.4; memberData.BeamData.WidthOfSupportRight = 0.4; Sections, Extremes, Internal forces The reinforced cross-section and the check member are defined for the checked section. Extremes of internal forces (for ULS and SLS calculation) are set in the checked section data there. For assessment of limit states, actual internal forces into the analyzed cross-section need to be insert. //Standard section var singleCheckSection = new StandardCheckSection(); singleCheckSection.Description = \"S 1\"; singleCheckSection.ReinfSection = new ReferenceElement(rcs); singleCheckSection.CheckMember = new ReferenceElement(checkMember); //add extreme to section var sectionExtreme = new StandardCheckSectionExtreme(); //sectionExtreme.Name = \"S1 - E1\"; sectionExtreme.Fundamental = new LoadingULS(); sectionExtreme.Fundamental.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 150.0e3, Mz = 20.0e3, Qy = 5.0e3, Qz = 50.0e3 }; sectionExtreme.Characteristic = new LoadingSLS(); sectionExtreme.Characteristic.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 105.0e3, Mz = 14.0e3 }; sectionExtreme.QuasiPermanent = new LoadingSLS(); sectionExtreme.QuasiPermanent.InternalForces = new IdeaRS.OpenModel.Result.ResultOfInternalForces() { N = 0.0, My = 80.0e3, Mz = 7.0e3 }; singleCheckSection.Extremes.Add(sectionExtreme); openModel.AddObject(singleCheckSection); Calculation control This setting define, which type of assessment will be used and corresponding results will be displayed. memberData.CalculationSetup = new CalculationSetup(); memberData.CalculationSetup.UlsDiagram = true; memberData.CalculationSetup.UlsShear = true; memberData.CalculationSetup.UlsTorsion = true; memberData.CalculationSetup.UlsInteraction = true; memberData.CalculationSetup.SlsStressLimitation = true; memberData.CalculationSetup.SlsCrack = true; memberData.CalculationSetup.Detailing = true; memberData.CalculationSetup.UlsResponse = true; memberData.CalculationSetup.SlsStiffnesses = false; memberData.CalculationSetup.MNKappaDiagram = false; Concrete setup Creating the code setup used for assessment of cross-section including national annex settings. //Concrete setup var setup = new ConcreteSetupEc2(); setup.Annex = NationalAnnexCode.NoAnnex; openModel.ConcreteSetup = setup; Results In the followed example there is way how to run the check and the get results. Results are stored in the object with considered values for each assessment. //Creating instance of Rcs controller var rcsController = new IdeaStatiCa.RcsController.IdeaRcsController(); System.Diagnostics.Debug.Assert(rcsController != null); //Open rcs project from IOM IdeaRS.OpenModel.Message.OpenMessages messages; var ok = rcsController.OpenIdeaProjectFromIdeaOpenModel(openModel, \"Beam\", out messages); System.Diagnostics.Debug.Assert(ok); rcsController.SaveAsIdeaProjectFile(fileName); //Calculate project ok = rcsController.Calculate(new List<int>() { singleCheckSection.Id }); System.Diagnostics.Debug.Assert(ok); //gets the results var result = rcsController.GetResultOnSection(null); System.Diagnostics.Debug.Assert(result != null); var sectionResult = result.FirstOrDefault(it => it.SectionId == singleCheckSection.Id); System.Diagnostics.Debug.Assert(result != null); foreach (var extremeResult in sectionResult.ExtremeResults) { var overalResult = extremeResult.Overall; foreach (var check in overalResult.Checks) { System.Diagnostics.Debug.WriteLine(\"{0} - {1} - {2}\", check.ResultType, check.Result, check.CheckValue); } foreach (var checkResult in extremeResult.CheckResults) { var checkType = checkResult.ResultType; foreach (var checkResult1 in checkResult.CheckResults) { var res = checkResult1.Result; switch (checkResult.ResultType) { case IdeaRS.OpenModel.Concrete.CheckResult.CheckResultType.Capacity: var resultCapacity = checkResult1 as IdeaRS.OpenModel.Concrete.CheckResult.ConcreteULSCheckResultDiagramCapacityEc2; var fu1 = resultCapacity.Fu1; var fu2 = resultCapacity.Fu2; break; case IdeaRS.OpenModel.Concrete.CheckResult.CheckResultType.Shear: var resultShear = checkResult1 as IdeaRS.OpenModel.Concrete.CheckResult.ConcreteULSCheckResultShearEc2; var v_ed = resultShear.Ved; var v_rdc = resultShear.Vrdc; //.... break; case IdeaRS.OpenModel.Concrete.CheckResult.CheckResultType.CrackWidth: var resultCrackWidth = checkResult1 as IdeaRS.OpenModel.Concrete.CheckResult.ConcreteSLSCheckResultCrackWidthEc2; var w = resultCrackWidth.W; var wlim = resultCrackWidth.Wlim; //.... break; } if (checkResult1.NonConformities.Count > 0) { var issues = rcsController.GetNonConformityIssues(checkResult1.NonConformities.Select(it => it.Guid).ToList()); foreach (var issue in issues) { System.Diagnostics.Debug.WriteLine(issue.Description); } } } } } rcsController.Dispose();"
  },
  "examples/iom/iom-rcs/IomToRcsExamples/readme.html": {
    "href": "examples/iom/iom-rcs/IomToRcsExamples/readme.html",
    "title": "| IDEA StatiCa API",
    "keywords": ""
  },
  "examples/iom/python/steel_frame_example_python/iom_steel_frame_example_python.html": {
    "href": "examples/iom/python/steel_frame_example_python/iom_steel_frame_example_python.html",
    "title": "Creating a simple IOM model with Python | IDEA StatiCa API",
    "keywords": "Creating a simple IOM model with Python This example runs through how a simple steel frame structure can be created using the IDEA Open Model (IOM) and Python. This example follows along very similarly to the c# steel frame example Define and reference IOM .dlls from the IDEA directory Import required .dlls, including some system collections. We will reference the IdeaRS.OpenModel .dll from the IDEA installation path. import clr import sys import json import math import os idea_path = \"C:\\Program Files\\IDEA StatiCa\\StatiCa 22.1\" sys.path.append(idea_path); clr.AddReference(\"System.Collections\") from System.Collections.Generic import List clr.AddReference(\"IdeaRS.OpenModel\") #This allows us to quickly create the open Model Object from IdeaRS.OpenModel import OpenModel #This import allows us to quickly create objects which are referenced under the Open Model Namespace. from IdeaRS import OpenModel as IOM Create Open Model Create the open model object to which we will start to add objects. model = OpenModel() Project settings Basic information about our project - such as a project name, a description, etc. Specification of the project country code is also important. originSettings = IOM.OriginSettings() originSettings.CrossSectionConversionTable = IOM.CrossSectionConversionTable.SCIA originSettings.CountryCode = IOM.CountryCode.ECEN originSettings.ProjectName = \"Project\" originSettings.Author = \"IDEA StatiCa s.r.o.\" originSettings.ProjectDescription = \"Training example\" model.OriginSettings = originSettings Definition of materials in the model Note that materials are code specific. material = IOM.Material.MatSteelEc2() #set properties material.Id = 1 material.Name = \"S355\" #material.LoadFromLibrary = True; material.E = 210000000000 material.G = material.E / (2 * (1 + 0.3)) material.Poisson = 0.3 material.UnitMass = 7850 material.SpecificHeat = 0.6 material.ThermalExpansion = 0.000012 material.ThermalConductivity = 45 material.IsDefaultMaterial = False material.OrderInCode = 0 material.StateOfThermalExpansion = IOM.Material.ThermalExpansionState.Code material.StateOfThermalConductivity = IOM.Material.ThermalConductivityState.Code material.StateOfThermalSpecificHeat = IOM.Material.ThermalSpecificHeatState.Code material.StateOfThermalStressStrain = IOM.Material.ThermalStressStrainState.Code material.StateOfThermalStrain = IOM.Material.ThermalStrainState.Code material.fy = 355000000 material.fu = 510000000 material.fy40 = 335000000 material.fu40 = 470000000 material.DiagramType = IOM.Material.SteelDiagramType.Bilinear #add material to the model model.AddObject(material); Definition of cross sections in the model We will add two different I Shape cross sections to the model: HE200B and HE240B. To create a single cross-section we will reference the material created in the previous section. The IOM ReferenceElement is used to reference different objects to others in an IOM model. # We can directly reference the material we create above as a reference element. css1 = IOM.CrossSection.CrossSectionParameter() css1.Id = 1; css1.Name = \"HE200B\" css1.Material = IOM.ReferenceElement(material) IOM.CrossSection.CrossSectionFactory.FillRolledI(css1, \"HE200B\") css2 = IOM.CrossSection.CrossSectionParameter() css2.Id = 2; css2.Name = \"HE240B\" css2.Material = IOM.ReferenceElement(material) IOM.CrossSection.CrossSectionFactory.FillRolledI(css2, \"HE240B\") #add both cross-sections to the model model.AddObject(css1) model.AddObject(css2) # We can save our progress at any time using the `SaveToXmlFile()` method. model.SaveToXmlFile('progressIOM.xml') Model Geometry Create Nodes Table of all nodes with given coordinates: Node X Y Z N1 -2 3 0 N2 -2 3 3 N3 2 3 0 N4 2 3 3 N5 6 3 0 N6 6 3 3 N7 -2 3 6 N8 2 3 6 N9 6 3 6 # For ease I have created a List of List of Node Co-ordinates nodes = [[-2,3,0],[-2,3,3],[2,3,0],[2,3,3],[6,3,0],[6,3,3],[-2,3,6],[2,3,6],[6,3,6]] for i, pt in enumerate(nodes): Point = IOM.Geometry3D.Point3D() Point.X = nodes[i][0] Point.Y = nodes[i][1] Point.Z = nodes[i][2] Point.Name = \"N{0}\".format(i+1) Point.Id = i+1 model.AddObject(Point) Add Members to the Model Members are made up of one or more elements. Each element is to be created with a reference to a LineSegment3D. The LineSegment3D contains the local coordinate system of the member. By default a Z-up coordinate system is defined for all Line Segments. LineSegment3D The local coordinate system of members It its important to pay attantion to the correct setting of coordinate systems of members. It must correspond to coordinate systems which are used in your FEA model otherwise it can caused unbalanced internal forces in exported connections. # The `transformCoordsystem` input says whether the member should be assigned based on a standard vertical member axis system or not. def CreateLineSegment3D(startNode, endNode, transformCoordSystem): segment3D = IOM.Geometry3D.LineSegment3D() segmentid = model.GetMaxId(segment3D) + 1 segment3D.Id = segmentid st = next((x for x in model.Point3D if x.Id == startNode), None) end = next((x for x in model.Point3D if x.Id == endNode), None) segment3D.StartPoint = IOM.ReferenceElement(st) segment3D.EndPoint = IOM.ReferenceElement(end) if transformCoordSystem: system = IOM.Geometry3D.CoordSystemByPoint() pointref = IOM.Geometry3D.Point3D() pointref.X = 100000 pointref.Y = 0 pointref.Z = 0 system.Point = pointref system.InPlane = IOM.Geometry3D.Plane.ZX; segment3D.LocalCoordinateSystem = system; return segment3D; Member Helper Functions Below are two helper functions that allow for the required elements of a member to be automatically created. The first helper function will create a member between two nodes only, while the second creates a continuous member with an intermediate node. #Creates a member with only a start and end point def CreateSingleMember(memberType, startNode, endNode): member = IOM.Model.Member1D() columnLCS = False if memberType == \"C\": columnLCS = True #create line segment line = CreateLineSegment3D(startNode, endNode, columnLCS) model.AddObject(line) #create Element element = IOM.Model.Element1D() elementid = model.GetMaxId(element) + 1 element.Id = elementid element.Name = \"E{0}\".format(elementid) element.Segment = IOM.ReferenceElement(line) model.AddObject(element) #assign Elements member.Elements1D.Add(IOM.ReferenceElement(element)) return member #Creates a member with a start an end and a middle point def CreateDoubleMember(memberType, startNode, middleNode, endNode): member = IOM.Model.Member1D() columnLCS = False if memberType == \"C\": columnLCS = True #create line segments line1 = IOM.Geometry3D.LineSegment3D() line2 = IOM.Geometry3D.LineSegment3D() line1 = CreateLineSegment3D(startNode, middleNode, columnLCS) model.AddObject(line1) line2 = CreateLineSegment3D(middleNode, endNode, columnLCS) model.AddObject(line2) #create Element 1 element1 = IOM.Model.Element1D() elementid = model.GetMaxId(element1) + 1 element1.Id = elementid element1.Name = \"E{0}\".format(elementid) element1.Segment = IOM.ReferenceElement(line1) model.AddObject(element1) #create Element 1 element2 = IOM.Model.Element1D() elementid = model.GetMaxId(element2) + 1 element2.Id = elementid element2.Name = \"E{0}\".format(elementid) element2.Segment = IOM.ReferenceElement(line2) model.AddObject(element2) #assign Elements member.Elements1D.Add(IOM.ReferenceElement(element1)) member.Elements1D.Add(IOM.ReferenceElement(element2)) return member Create Members Using the helper functions defined above we will create and add members to the model based on the basic input provided below. Here the 'B' defined at the start of the list denotes a beam and the 'C' denotes a column. The Integers denote the start, intermediate (if any) and end nodes. [[\"B\",2,4],[\"B\",4,6],[\"C\",1,2,7],[\"C\",3,4,8],[\"C\",5,6,9],[\"B\",7,8,9]] #For simplicity create a List of List of the Member Type and Start, Middle and End Nodes memberNodeDefs = [[\"B\",2,4],[\"B\",4,6],[\"C\",1,2,7],[\"C\",3,4,8],[\"C\",5,6,9],[\"B\",7,8,9]] #We can retrieve the appropriate cross-sections from the Model that we want to apply to the beams and columns respectively. css_he_200b = next((x for x in model.CrossSection if x.Name == \"HE200B\"), None) css_he_240b = next((x for x in model.CrossSection if x.Name == \"HE240B\"), None) #create all members for i, memberDef in enumerate(memberNodeDefs): memberType = memberDef[0] memberid = i+1 member = IOM.Model.Member1D() if len(memberDef) < 4: member = CreateSingleMember(memberType, memberDef[1], memberDef[2]) else: member = CreateDoubleMember(memberType, memberDef[1], memberDef[2], memberDef[3]) member.Name = \"M{0}\".format(i+1) member.Id = i+1 if memberType == \"C\": member.Member1DType = IOM.Model.Member1DType.Column member.CrossSection = IOM.ReferenceElement(css_he_240b) else: member.Member1DType = IOM.Model.Member1DType.Beam member.CrossSection = IOM.ReferenceElement(css_he_200b) model.AddObject(member) Loading of the Steel Frame Define Load Groups and Load Cases # Create the load group for permanent load cases LG1 = IOM.Loading.LoadGroupEC() LG1.Id = 1 LG1.Name = \"PERM1\" LG1.Relation = IOM.Loading.Relation.Standard LG1.GroupType = IOM.Loading.LoadGroupType.Permanent LG1.GammaQ = 1.35 LG1.Dzeta = 0.85 LG1.GammaGInf = 1 LG1.GammaGSup = 1.35 model.AddObject(LG1) # Create the second load group for variable loadcases LG2 = IOM.Loading.LoadGroupEC() LG2.Id = 2; LG2.Name = \"VAR1\"; LG2.Relation = IOM.Loading.Relation.Exclusive; LG2.GroupType = IOM.Loading.LoadGroupType.Variable; LG2.GammaQ = 1.5; LG2.Dzeta = 0.85; LG2.GammaGInf = 0; LG2.GammaGSup = 1.5; LG2.Psi0 = 0.7; LG2.Psi1 = 0.5; LG2.Psi2 = 0.3; model.AddObject(LG2); # Create the first load case representing SelfWeight LC1 = IOM.Loading.LoadCase() LC1.Id = 1 LC1.Name = \"SelfWeight\" LC1.LoadType = IOM.Loading.LoadCaseType.Permanent LC1.Type = IOM.Loading.LoadCaseSubType.PermanentStandard LC1.Variable = IOM.Loading.VariableType.Standard LC1.LoadGroup = IOM.ReferenceElement(LG1) # Create the second load case representing Pernament Loading LC2 = IOM.Loading.LoadCase() LC2.Id = 2 LC2.Name = \"PernamentLoading\" LC2.LoadType = IOM.Loading.LoadCaseType.Permanent LC2.Type = IOM.Loading.LoadCaseSubType.PermanentStandard LC2.Variable = IOM.Loading.VariableType.Standard LC2.LoadGroup = IOM.ReferenceElement(LG1) # Create the third load case representing LiveLoad LC3 = IOM.Loading.LoadCase() LC3.Id = 3 LC3.Name = \"LiveLoad\" LC3.LoadType = IOM.Loading.LoadCaseType.Variable LC3.Type = IOM.Loading.LoadCaseSubType.VariableStatic LC3.Variable = IOM.Loading.VariableType.Standard LC3.LoadGroup = IOM.ReferenceElement(LG2) # Add load cases to the model model.AddObject(LC1); model.AddObject(LC2); model.AddObject(LC3); Define Load Combinations # create first combination input CI1 = IOM.Loading.CombiInputEC() CI1.Id = model.GetMaxId(CI1) + 1 CI1.Name = \"Co.#1\" CI1.Description = \"SelfWeight + PernamentLoading + LiveLoad\" CI1.TypeCombiEC = IOM.Loading.TypeOfCombiEC.ULS CI1.TypeCalculationCombi = IOM.Loading.TypeCalculationCombiEC.Linear item = IOM.Loading.CombiItem() item.Id = 1; item.Coeff = 1.35; item.LoadCase = IOM.ReferenceElement(next((x for x in model.CrossSection if x.Name == \"SelfWeight\"), None)); CI1.Items.Add(item); item = IOM.Loading.CombiItem(); item.Id = 2; item.Coeff = 1.35; item.LoadCase = IOM.ReferenceElement(next((x for x in model.CrossSection if x.Name == \"PernamentLoading\"), None)); CI1.Items.Add(item); item = IOM.Loading.CombiItem(); item.Id = 3; item.Coeff = 1.5; item.LoadCase = IOM.ReferenceElement(next((x for x in model.CrossSection if x.Name == \"LiveLoad\"), None)); CI1.Items.Add(item); model.AddObject(CI1); #create second combination input CI2 = IOM.Loading.CombiInputEC() CI2.Id = model.GetMaxId(CI2) + 1 CI2.Name = \"Co.#2\" CI2.Description = \"SelfWeight\" CI2.TypeCombiEC = IOM.Loading.TypeOfCombiEC.ULS CI2.TypeCalculationCombi = IOM.Loading.TypeCalculationCombiEC.Linear item = IOM.Loading.CombiItem(); item.Id = 1; item.Coeff = 1; item.LoadCase = IOM.ReferenceElement(next((x for x in model.CrossSection if x.Name == \"SelfWeight\"), None)); CI2.Items.Add(item); model.AddObject(CI2); IOM Model Results We will not define the results here but results can also be created using this means. We will reference a previously defined result file for this example. You can find some further information here: https://github.com/idea-statica/ideastatica-public/tree/main/src/Examples/IOM Congratulations, you have created an IOM Model from Scratch. Now let's define a Connection Point to allow us to import into IDEA StatiCa Connection. Define a Connection within the Model Now that the model has been created we should define a connection point and add the relevant members to it. A connection is defined by its reference node and connected members. A member can be ended or continuous. # create a connection point CP1 = IOM.Connection.ConnectionPoint() CP1.Node = IOM.ReferenceElement(next((x for x in model.Point3D if x.Name == \"N2\"), None)); conId = model.GetMaxId(CP1) + 1; CP1.Id = conId; CP1.Name = \"CON {0}\".format(conId); # members from the previous section # Let's get the members we want to connect in the connection. These will be M1 and M3. M3 will be continuous in the Connection while M1 will be ended. connectedMem1 = IOM.Connection.ConnectedMember() connectedMem1.IsContinuous = False; connectedMem1.Id = 1; connectedMem1.MemberId = IOM.ReferenceElement(next((x for x in model.Member1D if x.Name == \"M1\"), None)) connectedMem3 = IOM.Connection.ConnectedMember() connectedMem3.IsContinuous = True; connectedMem3.Id = 3; connectedMem3.MemberId = IOM.ReferenceElement(next((x for x in model.Member1D if x.Name == \"M3\"), None)) CP1.ConnectedMembers.Add(connectedMem1); CP1.ConnectedMembers.Add(connectedMem3); model.AddObject(CP1); Defining the ConnectionData We can now add additional connection data such as beam information, Plate, Bolt, Weld, and Cut information. We will only add some basic beam information here. Further information on adding additional info is explained here: https://github.com/idea-statica/ideastatica-public/tree/main/src/Examples/IOM conData = IOM.Connection.ConnectionData() beamData = List[IOM.Connection.BeamData]() beamData1 = IOM.Connection.BeamData() beamData1.Id = 1 beamData1.Name = \"M1\" beamData1.OriginalModelId = \"1\" beamData2 = IOM.Connection.BeamData() beamData2.Id = 3 beamData2.Name = \"M3\" beamData2.OriginalModelId = \"3\" beamData.Add(beamData1) beamData.Add(beamData2) conData.Beams = beamData model.Connections.Add(conData) Saving the Model Let's save the final model to drive. model.SaveToXmlFile('IOM-SteelFrame.xml') Congratulations, you have successfully created an IOM model and a connection point that can be imported into IDEA StatiCa Connection. Using IDEA Plugin to Generate the Connection Using the clr we need to reference the IdeaStatiCa.Plugin dll from the Idea Directory. Then Plugin Namespace we need to import the ConnHiddenClientFactory. The Client Factory allows us to safely create connection clients that we can use to interact with IDEA Connection. clr.AddReference('IdeaStatiCa.Plugin') from IdeaStatiCa.Plugin import ConnHiddenClientFactory We then again need to provide the path to the Client Factory and safely create a client. factory = ConnHiddenClientFactory(idea_path) client = factory.Create() Finally, create an Idea Connection file from an IOM referencing the saved filepath of the model, results and a new filepath to save the IDEA Connection (. IdeaCon) file to. client.CreateConProjFromIOM('IOM-SteelFrame.xml', 'IOM-SteelFrame.xmlR', 'SteelFrame.ideaCon') # Ensure closing of any open project and flush the client. client.CloseProject() client.Close()"
  },
  "examples/readme.html": {
    "href": "examples/readme.html",
    "title": "IDEA StatiCa SDK Examples | IDEA StatiCa API",
    "keywords": "IDEA StatiCa SDK Examples We provide a comprehensive list of examples for getting started with IDEA StatiCa's API. The examples folder structure is similar to the split up of the developer website and is as below. examples ├── iom │ ├── Examples related to Idea Open Model generation for different applications ├── api │ ├── dotnet │ │ ├── Examples related to Design App Api's using .Net (csharp) │ ├── python │ │ ├── Examples related to Design App Api's using Python ├── bimapi │ ├── Examples related to creating FEA and CAD BimLinks with Checkbot ├── extensions │ ├── Examples related to API extensions .Net Example Solution Within the examples folder we provide a standalone visual studio solution which contains all the examples relevant to .Net. To get access to this folder you should first clone the repository to your desktop and then navigate to the examples folder and open the IdeaStatiCa-SDK-Examples.sln. Each example project has two debug configurations 'Debug' and 'Debug_NuGet'. The projects in the IdeaStatiCa-SDK-Examples.sln are set to Debug_Nuget which means they referencee avaliable Nuget packages on build. As we still actively develop some of the examples avaliable against our source code we use 'Debug' for internal. Python Examples Python examples should be contained in a folder with everything you need to open and run a particular example. Python examples are not provided in the visual studio solution."
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to IDEA StatiCa API SDK | IDEA StatiCa API",
    "keywords": "Welcome to IDEA StatiCa API SDK The following should appeal to Software Developers and Computational Designers wishing to interface with IDEA StatiCa applications and services. The documentation is split into the below primary parts: IDEA Open Model (IOM) IDEA StatiCa's object model for exchanging data to and from FEA or CAD applications. IOM is open source and transfered using an XML file format. It is designed to interact natively with IDEA StatiCa applications. IOM is at the heart of all of our interoperability tools, therefore almost all advanced users will likely need to know the basics of Open Model. Get started here: IDEA Open Model (IOM) BIM Links with Checkbot (BIM API) If you are a third-party software developer looking to create a seamless integration with IDEA StatiCa Checkbot then the BIM API is where you should start. The BIM Api and BIM Api Link framework allow third-parties to create customised BIM Links with in-built features such as library conversions, model syncing and more. Get Started here: BIM API Design API's (API) IDEA StatiCa provides a number of general API's for the different apps and services that we provide. If you are a computational designer or software developer looking to perform automated structural design and optimisation tasks, this is a good place to start. Design API's are targeted toward both Python and C#/.Net users. Get started here: API Extensions Extensions are plugins and programs which are built on-top of the IDEA Open Model and API's and target low-code users. If you are a structural engineer or computational designer looking to automate workflows through visual programming then this will interest you. Our current extension are: Plugin for Rhino/Grasshopper"
  }
}